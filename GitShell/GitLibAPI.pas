{$I Defines.inc}

{$ALIGN ON}

unit GitLibAPI;

interface

uses
   Windows, MixUtils;


type
  PGitChar = PAnsiChar;

type
   int        = integer;
   uint32_t   = uint;
   uint16_t   = SHORT;
   size_t     = UIntPtr; //LongWord;
   time_t     = Int64;
   off_t      = Int64;
   git_off_t  = Int64;  //typedef __int64 git_off_t;
   git_time_t = Int64;  //typedef __time64_t git_time_t;
   PInt32_t   = ^Int32;
   PInt64_t   = PInt64;
   float      = single;

   git_otype            = Integer; // enum as constants above
   git_rtype            = Integer;
   git_odb_streammode   = Integer;

   git_file = Integer;


const
  // /** Size (in bytes) of a raw/binary oid */
  // #define GIT_OID_RAWSZ 20
  GIT_OID_RAWSZ = 20;

  // /** Size (in bytes) of a hex formatted oid */
  // #define GIT_OID_HEXSZ (GIT_OID_RAWSZ * 2)
  GIT_OID_HEXSZ = (GIT_OID_RAWSZ * 2);

  // #define GIT_OID_MINPREFIXLEN 4
  GIT_OID_MINPREFIXLEN = 4;

  // #define GIT_PACK_NAME_MAX (5 + 40 + 1)
  GIT_PACK_NAME_MAX = (5 + 40 + 1);


///** Basic type (loose or packed) of any Git object. */
//typedef enum {
//	GIT_OBJ_ANY = -2,		/**< Object can be any of the following */
//	GIT_OBJ_BAD = -1,		/**< Object is invalid. */
//	GIT_OBJ__EXT1 = 0,		/**< Reserved for future use. */
//	GIT_OBJ_COMMIT = 1,		/**< A commit object. */
//	GIT_OBJ_TREE = 2,		/**< A tree (directory listing) object. */
//	GIT_OBJ_BLOB = 3,		/**< A file revision object. */
//	GIT_OBJ_TAG = 4,		/**< An annotated tag object. */
//	GIT_OBJ__EXT2 = 5,		/**< Reserved for future use. */
//	GIT_OBJ_OFS_DELTA = 6, /**< A delta, base is given by an offset. */
//	GIT_OBJ_REF_DELTA = 7, /**< A delta, base is given by object id. */
//} git_otype;

  GIT_OBJ_ANY = -2;
  GIT_OBJ_BAD = -1;
  GIT_OBJ__EXT1 = 0;
  GIT_OBJ_COMMIT = 1;
  GIT_OBJ_TREE = 2;
  GIT_OBJ_BLOB = 3;
  GIT_OBJ_TAG = 4;
  GIT_OBJ__EXT2 = 5;
  GIT_OBJ_OFS_DELTA = 6;
  GIT_OBJ_REF_DELTA = 7;

///** Generic return codes */
//typedef enum {
//	GIT_OK         =  0,		/**< No error */
//
//	GIT_ERROR      = -1,		/**< Generic error */
//	GIT_ENOTFOUND  = -3,		/**< Requested object could not be found */
//	GIT_EEXISTS    = -4,		/**< Object exists preventing operation */
//	GIT_EAMBIGUOUS = -5,		/**< More than one object matches */
//	GIT_EBUFS      = -6,		/**< Output buffer too short to hold data */
//
//	/* GIT_EUSER is a special error that is never generated by libgit2
//	 * code.  You can return it from a callback (e.g to stop an iteration)
//	 * to know that it was generated by the callback and not by libgit2.
//	 */
//	GIT_EUSER      = -7,
//
//	GIT_EBAREREPO       =  -8,	/**< Operation not allowed on bare repository */
//	GIT_EUNBORNBRANCH   =  -9,	/**< HEAD refers to branch with no commits */
//	GIT_EUNMERGED       = -10,	/**< Merge in progress prevented operation */
//	GIT_ENONFASTFORWARD = -11,	/**< Reference was not fast-forwardable */
//	GIT_EINVALIDSPEC    = -12,	/**< Name/ref spec was not in a valid format */
//	GIT_ECONFLICT       = -13,	/**< Checkout conflicts prevented operation */
//	GIT_ELOCKED         = -14,	/**< Lock file prevented operation */
//	GIT_EMODIFIED       = -15,	/**< Reference value does not match expected */
//	GIT_EAUTH           = -16,      /**< Authentication error */
//	GIT_ECERTIFICATE    = -17,      /**< Server certificate is invalid */
//	GIT_EAPPLIED        = -18,	/**< Patch/merge has already been applied */
//	GIT_EPEEL           = -19,      /**< The requested peel operation is not possible */
//	GIT_EEOF            = -20,      /**< Unexpected EOF */
//	GIT_EINVALID        = -21,      /**< Invalid operation or input */
//	GIT_EUNCOMMITTED    = -22,	/**< Uncommitted changes in index prevented operation */
//	GIT_EDIRECTORY      = -23,      /**< The operation is not valid for a directory */
//	GIT_EMERGECONFLICT  = -24,	/**< A merge conflict exists and cannot continue */
//
//	GIT_PASSTHROUGH     = -30,	/**< Internal only */
//	GIT_ITEROVER        = -31,	/**< Signals end of iteration with iterator */
//	GIT_RETRY           = -32,	/**< Internal only */
//	GIT_EMISMATCH       = -33,	/**< Hashsum mismatch in object */
//} git_error_code;

   GIT_SUCCESS                =  0;

   GIT_ERROR                  = -1;
   GIT_ENOTFOUND              = -3;
   GIT_EEXISTS                = -4;
   GIT_EAMBIGUOUS             = -5;
   GIT_EBUFS                  = -6;

   GIT_EUSER                  = -7;

   GIT_EBAREREPO              =  -8;
   GIT_EUNBORNBRANCH          =  -9;
   GIT_EUNMERGED              = -10;
   GIT_ENONFASTFORWARD        = -11;
   GIT_EINVALIDSPEC           = -12;
   GIT_ECONFLICT              = -13;
   GIT_ELOCKED                = -14;
   GIT_EMODIFIED              = -15;
   GIT_EAUTH                  = -16;
   GIT_ECERTIFICATE           = -17;
   GIT_EAPPLIED               = -18;
   GIT_EPEEL                  = -19;
   GIT_EEOF                   = -20;
   GIT_EINVALID               = -21;
   GIT_EUNCOMMITTED           = -22;
   GIT_EDIRECTORY             = -23;
   GIT_EMERGECONFLICT         = -24;

   GIT_PASSTHROUGH            = -30;
   GIT_ITEROVER               = -31;
   GIT_RETRY                  = -32;
   GIT_EMISMATCH              = -33;

//
//   /**
//    * Sort the repository contents in no particular ordering;
//    * this sorting is arbitrary, implementation-specific
//    * and subject to change at any time.
//    * This is the default sorting for new walkers.
//    */
//   #define GIT_SORT_NONE         (0)
//
//   /**
//    * Sort the repository contents in topological order
//    * (parents before children); this sorting mode
//    * can be combined with time sorting.
//    */
//   #define GIT_SORT_TOPOLOGICAL  (1 << 0)
//
//   /**
//    * Sort the repository contents by commit time;
//    * this sorting mode can be combined with
//    * topological sorting.
//    */
//   #define GIT_SORT_TIME         (1 << 1)
//
//   /**
//    * Iterate through the repository contents in reverse
//    * order; this sorting mode can be combined with
//    * any of the above.
//    */
//   #define GIT_SORT_REVERSE      (1 << 2)
   GIT_SORT_NONE        = (0);
   GIT_SORT_TOPOLOGICAL = (1 shl 0);
   GIT_SORT_TIME        = (1 shl 1);
   GIT_SORT_REVERSE     = (1 shl 2);

//   /** Basic type of any Git reference. */
//   typedef enum {
//      GIT_REF_INVALID = 0, /** Invalid reference */
//      GIT_REF_OID = 1, /** A reference which points at an object id */
//      GIT_REF_SYMBOLIC = 2, /** A reference which points at another reference */
//      GIT_REF_PACKED = 4,
//      GIT_REF_HAS_PEEL = 8,
//      GIT_REF_LISTALL = GIT_REF_OID|GIT_REF_SYMBOLIC|GIT_REF_PACKED,
//   } git_rtype

   GIT_REF_INVALID   = 0;
   GIT_REF_OID       = 1;
   GIT_REF_SYMBOLIC  = 2;
   GIT_REF_PACKED    = 4;
   GIT_REF_HAS_PEEL  = 8;
   GIT_REF_LISTALL   = GIT_REF_OID or GIT_REF_SYMBOLIC or GIT_REF_PACKED;

//      typedef enum {
//      GIT_STREAM_RDONLY = (1 << 1),
//      GIT_STREAM_WRONLY = (1 << 2),
//      GIT_STREAM_RW = (GIT_STREAM_RDONLY | GIT_STREAM_WRONLY),
//   } git_odb_streammode;

   GIT_STREAM_RDONLY = (1 shl 1);
   GIT_STREAM_WRONLY = (1 shl 2);
   GIT_STREAM_RW     = (GIT_STREAM_RDONLY or GIT_STREAM_WRONLY);

//   #define GIT_IDXENTRY_UPDATE            (1 << 0)
//   #define GIT_IDXENTRY_REMOVE            (1 << 1)
//   #define GIT_IDXENTRY_UPTODATE          (1 << 2)
//   #define GIT_IDXENTRY_ADDED             (1 << 3)
//
//   #define GIT_IDXENTRY_HASHED            (1 << 4)
//   #define GIT_IDXENTRY_UNHASHED          (1 << 5)
//   #define GIT_IDXENTRY_WT_REMOVE         (1 << 6) /* remove in work directory */
//   #define GIT_IDXENTRY_CONFLICTED        (1 << 7)
//
//   #define GIT_IDXENTRY_UNPACKED          (1 << 8)
//   #define GIT_IDXENTRY_NEW_SKIP_WORKTREE (1 << 9)
//
//   /*
//    * Extended on-disk flags:
//    */
//   #define GIT_IDXENTRY_INTENT_TO_ADD     (1 << 13)
//   #define GIT_IDXENTRY_SKIP_WORKTREE     (1 << 14)
//   /* GIT_IDXENTRY_EXTENDED2 is for future extension */
//   #define GIT_IDXENTRY_EXTENDED2         (1 << 15)
//
//   #define GIT_IDXENTRY_EXTENDED_FLAGS (GIT_IDXENTRY_INTENT_TO_ADD | GIT_IDXENTRY_SKIP_WORKTREE)
   GIT_IDXENTRY_UPDATE              = (1 shl 0);
   GIT_IDXENTRY_REMOVE              = (1 shl 1);
   GIT_IDXENTRY_UPTODATE            = (1 shl 2);
   GIT_IDXENTRY_ADDED               = (1 shl 3);

   GIT_IDXENTRY_HASHED              = (1 shl 4);
   GIT_IDXENTRY_UNHASHED            = (1 shl 5);
   GIT_IDXENTRY_WT_REMOVE           = (1 shl 6); //* remove in work directory */
   GIT_IDXENTRY_CONFLICTED          = (1 shl 7);

   GIT_IDXENTRY_UNPACKED            = (1 shl 8);
   GIT_IDXENTRY_NEW_SKIP_WORKTREE   = (1 shl 9);

// * Extended on-disk flags:
   GIT_IDXENTRY_INTENT_TO_ADD       = (1 shl 13);
   GIT_IDXENTRY_SKIP_WORKTREE       = (1 shl 14);
//* GIT_IDXENTRY_EXTENDED2 is for future extension */
   GIT_IDXENTRY_EXTENDED2           = (1 shl 15);

   GIT_IDXENTRY_EXTENDED_FLAGS      = (GIT_IDXENTRY_INTENT_TO_ADD or GIT_IDXENTRY_SKIP_WORKTREE);


   GIT_HEAD_FILE:       PAnsiChar = 'HEAD';
   GIT_MERGE_HEAD_FILE: PAnsiChar = 'MERGE_HEAD';
   GIT_DIR:             PAnsiChar = '.git/';
   GIT_INDEX_FILE:      PAnsiChar = 'index';
   GIT_OBJECTS_DIR:     PAnsiChar = 'objects/';
   GIT_REFS_HEADS_DIR:  PAnsiChar = 'heads/';
   GIT_PACKEDREFS_FILE: PAnsiChar = 'packed-refs';
   GIT_REFS_TAGS_DIR:   PAnsiChar = 'refs/tags/';

   GIT_DIR_FETCH                    = 0;
   GIT_DIR_PUSH                     = 1;

type
//   typedef struct {
//      /** raw binary formatted id */
//      unsigned char id[GIT_OID_RAWSZ];
//   } git_oid;
   git_oid = record
      id: array[0..GIT_OID_RAWSZ-1] of Byte;
   end;

//   /** Time in a signature */
//   typedef struct git_time {
//      time_t time; /** time in seconds from epoch */
//      int offset; /** timezone offset, in minutes */
//   } git_time;
   git_time = record
      time   :time_t;
      offset :Integer;
   end;

//   /** An action signature (e.g. for committers, taggers, etc) */
//   typedef struct git_signature {
//      char *name; /** full name of the author */
//      char *email; /** email of the author */
//      git_time when; /** time when the action happened */
//   } git_signature;
   git_signature = record
      name  :PAnsiChar;
      email :PAnsiChar;
      when  :git_time;
   end;


   TStrArray = array[0 .. MaxInt div SizeOf(PAnsiChar) - 1] of PAnsiChar;
   PStrArray = ^TStrArray;

// typedef struct {
//    char **strings;
//    size_t count;
// } git_strarray;
   git_strarray = record
      strings :PStrArray;
      count :size_t;
   end;

// typedef struct {
//   char   *ptr;
//   size_t asize, size;
// } git_buf;
   git_buf = record
     ptr :PAnsiChar;
     asize :size_t;
     size :size_t;
   end;


   PPByte = ^PByte;
   Pgit_oid = ^git_oid;
   PPgit_oid = ^Pgit_oid;
   PPgit_odb = ^Pgit_odb;
   PPgit_commit = ^Pgit_commit;
   PPgit_index_entry = ^Pgit_index_entry;
   Pgit_index_entry = ^git_index_entry;
   PPgit_index_tree = ^Pgit_index_tree;
   Pgit_signature = ^git_signature;
   PPgit_tree_entry = ^Pgit_tree_entry;
   Pgit_odb_backend = ^git_odb_backend;
   Pgit_strarray = ^git_strarray;
   Pgit_index_entry_unmerged = ^git_index_entry_unmerged;
   Pgit_config_file  = ^git_config_file;

   // structs not translated because they should be internal details,
   // and not necessary from GitForDelphi
   Pgit_odb          = Pointer;
   Pgit_commit       = Pointer;
   Pgit_index        = Pointer;
   Pgit_index_tree   = Pointer;
   Pgit_object       = Pointer;
   Pgit_tree         = Pointer;
   Pgit_tag          = Pointer;
   Pgit_blob         = Pointer;
   Pgit_repository   = Pointer;
   Pgit_tree_entry   = Pointer;
   Pgit_rawobj       = Pointer;
   Pgit_odb_object   = Pointer;
   Pgit_odb_stream   = Pointer;
   Pgit_revwalk      = Pointer;
   Pgit_treebuilder  = Pointer;
   Pgit_config       = Pointer;
   Pgit_indexer      = Pointer;
   Pgit_indexer_stats= Pointer;
   Pgit_reflog       = Pointer;
   Pgit_reflog_entry = Pointer;
   Pgit_remote       = Pointer;
   Pgit_refspec      = Pointer;

   PGitRepository    = Pointer;
   PGitStatusList    = Pointer;
   PGitReference     = Pointer;
   PGitObject        = Pointer;
   PGitBlob          = Pointer;
   PGitRemote        = Pointer;

   TGitOID           = git_oid;
   PGitOid           = ^TGitOID;
   PGitRevwalk       = Pointer;
   PGitCommit        = Pointer;
   PGitCommitArray   = ^PGitCommit;
   PGitAnnotCommit   = Pointer;
   PGitTree          = Pointer;
   PGitIndex         = Pointer;
   PGitDiff          = Pointer;
   PGitPathspec      = Pointer;

   PGitBranchIterator = pointer;

   TGitSignature     = git_signature;
   PGitSignature     = ^TGitSignature;

   TGitStrArray      = git_strarray;
   PGitStrArray      = ^TGitStrArray;

   TGitBuf           = git_buf;
   PGitBuf           = ^TGitBuf;

//   typedef int (*git_vector_cmp)(const void *, const void *);
   git_vector_cmp = Pointer;

   // int (*callback)(const char *, void *)
   git_reference_foreach_callback = function (const name: PAnsiChar; payload: PByte): Integer; stdcall;
   Pgit_reference_foreach_callback = ^git_reference_foreach_callback;

   // int (*callback)(const char *, unsigned int, void *)
   git_status_foreach_callback = function (const name: PAnsiChar; flags: UInt; payload: PByte): Integer; cdecl;
   Pgit_status_foreach_callback = ^git_status_foreach_callback;

   // typedef int (*git_treewalk_cb)(const char *root, git_tree_entry *entry, void *payload);
   git_treewalk_cb = function(root: PAnsiChar; entry: Pgit_tree_entry; payload: PByte): Integer; stdcall;
   Pgit_treewalk_cb = ^git_treewalk_cb;


//   struct git_remote_head {
//      int local:1; /* available locally */
//      git_oid oid;
//      git_oid loid;
//      char *name;
//   };
   git_remote_head = record
      local:                                             Integer;
      oid:                                               git_oid;
      loid:                                              git_oid;
      name:                                              PAnsiChar;
   end;
   Pgit_remote_head = ^git_remote_head;

   // typedef int (*git_headlist_cb)(git_remote_head *, void *);
   git_headlist_cb = function (head: Pgit_remote_head; payload: PByte): Integer; stdcall;
   Pgit_headlist_cb = ^git_headlist_cb;

//   struct git_odb_backend {
//      git_odb *odb;
//
//      int (* read)(
//            void **, size_t *, git_otype *,
//            struct git_odb_backend *,
//            const git_oid *);
//
//      /* To find a unique object given a prefix
//       * of its oid.
//       * The oid given must be so that the
//       * remaining (GIT_OID_HEXSZ - len)*4 bits
//       * are 0s.
//       */
//      int (* read_prefix)(
//            git_oid *,
//            void **, size_t *, git_otype *,
//            struct git_odb_backend *,
//            const git_oid *,
//            unsigned int);
//
//      int (* read_header)(
//            size_t *, git_otype *,
//            struct git_odb_backend *,
//            const git_oid *);
//
//      int (* write)(
//            git_oid *,
//            struct git_odb_backend *,
//            const void *,
//            size_t,
//            git_otype);
//
//      int (* writestream)(
//            struct git_odb_stream **,
//            struct git_odb_backend *,
//            size_t,
//            git_otype);
//
//      int (* readstream)(
//            struct git_odb_stream **,
//            struct git_odb_backend *,
//            const git_oid *);
//
//      int (* exists)(
//            struct git_odb_backend *,
//            const git_oid *);
//
//      void (* free)(struct git_odb_backend *);
//   };
   git_odb_backend_read          = function (var buffer_p: PByte; var len_p: size_t; var type_p: git_otype; backend: Pgit_odb_backend; const oid: Pgit_oid ): Integer; stdcall;
   git_odb_backend_read_prefix   = function (id: Pgit_oid; var buffer_p: PByte; var len_p: size_t; var type_p: git_otype; backend: Pgit_odb_backend; const short_oid: Pgit_oid; len: UInt): Integer; stdcall;
   git_odb_backend_read_header   = function (var len_p: size_t; var type_p: git_otype; backend: Pgit_odb_backend; const oid: Pgit_oid ): Integer; stdcall;
   git_odb_backend_write         = function (id: Pgit_oid; backend: Pgit_odb_backend; const data: PByte; len: size_t; type_: git_otype): Integer; stdcall;
   git_odb_backend_writestream   = function (var stream_out: Pgit_odb_stream; backend: Pgit_odb_backend; length: size_t; type_: git_otype): Integer; stdcall;
   git_odb_backend_readstream    = function (var stream_out: Pgit_odb_stream; backend: Pgit_odb_backend; const oid: Pgit_oid): Integer; stdcall;
   git_odb_backend_exists        = function (backend: Pgit_odb_backend; const oid: Pgit_oid): Integer; stdcall;
   git_odb_backend_free          = procedure (backend: Pgit_odb_backend); stdcall;

   git_odb_backend = record
      odb:                                               Pgit_odb;

      read:                                              ^git_odb_backend_read;
      read_prefix:                                       ^git_odb_backend_read_prefix;
      read_header:                                       ^git_odb_backend_read_header;
      write:                                             ^git_odb_backend_write;
      writestream:                                       ^git_odb_backend_writestream;
      readstream:                                        ^git_odb_backend_readstream;
      exists:                                            ^git_odb_backend_exists;
      free:                                              ^git_odb_backend_free;
   end;

//   typedef struct {
//      git_time_t seconds;
//      /* nsec should not be stored as time_t compatible */
//      unsigned int nanoseconds;
//   } git_index_time;
   git_index_time = record
      seconds:                                           git_time_t;
      nanoseconds:                                       UInt;
   end;

//   typedef struct git_index_entry {
//      git_index_time ctime;
//      git_index_time mtime;
//
//      unsigned int dev;
//      unsigned int ino;
//      unsigned int mode;
//      unsigned int uid;
//      unsigned int gid;
//      git_off_t file_size;
//
//      git_oid oid;
//
//      unsigned short flags;
//      unsigned short flags_extended;
//
//      const char *path;
//   } git_index_entry;
   git_index_entry = record
      ctime:                                             git_index_time;
      mtime:                                             git_index_time;

      dev:                                               UInt;
      ino:                                               UInt;
      mode:                                              UInt;
      uid:                                               UInt;
      gid:                                               UInt;
      file_size:                                         git_off_t;

      oid:                                               git_oid;

      flags:                                             SHORT;
      flags_extended:                                    SHORT;

      path:                                              PAnsiChar;
   end;

//   typedef struct git_index_entry_unmerged {
//      unsigned int mode[3];
//      git_oid oid[3];
//      char *path;
//   } git_index_entry_unmerged;
   git_index_entry_unmerged = record
      mode:                                              array [0..2] of UInt;
      oid:                                               array [0..2] of git_oid;
      path:                                              PAnsiChar;
   end;

//   typedef struct {
//      volatile int val;
//   } git_atomic;
   git_atomic = record
      val:                                               Integer;
   end;

//   typedef struct {
//      git_oid oid;
//      git_atomic refcount;
//   } git_cached_obj;
   git_cached_obj = record
      oid:                                               git_oid;
      refcount:                                          git_atomic;
   end;


   Pgit_treebuilder_filter_filter = ^git_treebuilder_filter_filter;
   git_treebuilder_filter_filter = function (const entry: Pgit_tree_entry; payload: PByte): Integer; stdcall;

   Pgit_config_file_foreach_callback = ^git_config_file_foreach_callback;
   git_config_file_foreach_callback = function (const key, value: PAnsiChar; data: PByte): Integer; stdcall;

   Pgit_config_file_open = ^git_config_file_open;
   Pgit_config_file_get = ^git_config_file_get;
   Pgit_config_file_set = ^git_config_file_set;
   Pgit_config_file_del = ^git_config_file_del;
   Pgit_config_file_foreach = ^git_config_file_foreach;
   Pgit_config_file_free = ^git_config_file_free;

   git_config_file_open    = function (f: Pgit_config_file): Integer; stdcall;
   git_config_file_get     = function (f: Pgit_config_file; const key: PAnsiChar; out value: PAnsiChar): Integer; stdcall;
   git_config_file_set     = function (f: Pgit_config_file; const key, value: PAnsiChar): Integer; stdcall;
   git_config_file_del     = function (f: Pgit_config_file; const key: PAnsiChar): Integer; stdcall;
   git_config_file_foreach = function (f: Pgit_config_file; fn: Pgit_config_file_foreach_callback; data: PByte): Integer; stdcall;
   git_config_file_free    = function (f: Pgit_config_file): Integer; stdcall;

//   struct git_config_file {
//      struct git_config *cfg;
//
//      /* Open means open the file/database and parse if necessary */
//      int (*open)(struct git_config_file *);
//      int (*get)(struct git_config_file *, const char *key, const char **value);
//      int (*set)(struct git_config_file *, const char *key, const char *value);
//      int (*del)(struct git_config_file *, const char *key);
//      int (*foreach)(struct git_config_file *, int (*fn)(const char *, void *), void *data);
//      void (*free)(struct git_config_file *);
//   };
   git_config_file = record
      cfg:                                               Pgit_config;

      open:                                              Pgit_config_file_open;
      get:                                               Pgit_config_file_get;
      set_:                                              Pgit_config_file_set;
      del:                                               Pgit_config_file_del;
      foreach:                                           Pgit_config_file_foreach;
      free:                                              Pgit_config_file_free;
   end;

//   int (*callback)(const char *var_name, const char *value, void *payload)
   Pgit_config_foreach_callback = ^git_config_foreach_callback;
   git_config_foreach_callback = function (const key, value: PAnsiChar; payload: PByte): Integer; stdcall;

//   int (*callback)(const char *name, const char *value, void *payload)
   Pgit_attr_foreach_callback = ^git_attr_foreach_callback;
   git_attr_foreach_callback = function (name, value: PAnsiChar; payload: PByte): Integer; stdcall;

//   typedef enum {
//      GIT_REPO_PATH,
//      GIT_REPO_PATH_INDEX,
//      GIT_REPO_PATH_ODB,
//      GIT_REPO_PATH_WORKDIR
//   } git_repository_pathid;
const
   GIT_REPO_PATH           = 0;
   GIT_REPO_PATH_INDEX     = 1;
   GIT_REPO_PATH_ODB       = 2;
   GIT_REPO_PATH_WORKDIR   = 3;
type
   git_repository_pathid = Integer;



//typedef enum {
//	GIT_STATUS_SHOW_INDEX_AND_WORKDIR = 0,
//	GIT_STATUS_SHOW_INDEX_ONLY = 1,
//	GIT_STATUS_SHOW_WORKDIR_ONLY = 2,
//} git_status_show_t;
const
  GIT_STATUS_SHOW_INDEX_AND_WORKDIR = 0;
  GIT_STATUS_SHOW_INDEX_ONLY = 1;
  GIT_STATUS_SHOW_WORKDIR_ONLY = 2;


(* git_status_opt_t
 Flags to control status callbacks

 - GIT_STATUS_OPT_INCLUDE_UNTRACKED says that callbacks should be made
   on untracked files.  These will only be made if the workdir files are
   included in the status "show" option.

 - GIT_STATUS_OPT_INCLUDE_IGNORED says that ignored files get callbacks.
   Again, these callbacks will only be made if the workdir files are
   included in the status "show" option.

 - GIT_STATUS_OPT_INCLUDE_UNMODIFIED indicates that callback should be
   made even on unmodified files.

 - GIT_STATUS_OPT_EXCLUDE_SUBMODULES indicates that submodules should be
   skipped.  This only applies if there are no pending typechanges to
   the submodule (either from or to another type).

 - GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS indicates that all files in
   untracked directories should be included.  Normally if an entire
   directory is new, then just the top-level directory is included (with
   a trailing slash on the entry name).  This flag says to include all
   of the individual files in the directory instead.

 - GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH indicates that the given path
   should be treated as a literal path, and not as a pathspec pattern.
 - GIT_STATUS_OPT_RECURSE_IGNORED_DIRS indicates that the contents of
   ignored directories should be included in the status.  This is like
   doing `git ls-files -o -i --exclude-standard` with core git.

 - GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX indicates that rename detection
   should be processed between the head and the index and enables
   the GIT_STATUS_INDEX_RENAMED as a possible status flag.

 - GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR indicates that rename
   detection should be run between the index and the working directory
   and enabled GIT_STATUS_WT_RENAMED as a possible status flag.

 - GIT_STATUS_OPT_SORT_CASE_SENSITIVELY overrides the native case
   sensitivity for the file system and forces the output to be in
   case-sensitive order

 - GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY overrides the native case
   sensitivity for the file system and forces the output to be in
   case-insensitive order

 - GIT_STATUS_OPT_RENAMES_FROM_REWRITES indicates that rename detection
   should include rewritten files

 - GIT_STATUS_OPT_NO_REFRESH bypasses the default status behavior of
   doing a "soft" index reload (i.e. reloading the index data if the
   file on disk has been modified outside libgit2).

 - GIT_STATUS_OPT_UPDATE_INDEX tells libgit2 to refresh the stat cache
   in the index for files that are unchanged but have out of date stat
   information in the index.  It will result in less work being done on
   subsequent calls to get status.  This is mutually exclusive with the
   NO_REFRESH option.

 Calling `git_status_foreach()` is like calling the extended version
 with: GIT_STATUS_OPT_INCLUDE_IGNORED, GIT_STATUS_OPT_INCLUDE_UNTRACKED,
 and GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS.  Those options are bundled
 together as `GIT_STATUS_OPT_DEFAULTS` if you want them as a baseline.

typedef enum {
	GIT_STATUS_OPT_INCLUDE_UNTRACKED                = (1u << 0),
	GIT_STATUS_OPT_INCLUDE_IGNORED                  = (1u << 1),
	GIT_STATUS_OPT_INCLUDE_UNMODIFIED               = (1u << 2),
	GIT_STATUS_OPT_EXCLUDE_SUBMODULES               = (1u << 3),
	GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS           = (1u << 4),
	GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH           = (1u << 5),
	GIT_STATUS_OPT_RECURSE_IGNORED_DIRS             = (1u << 6),
	GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX            = (1u << 7),
	GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR         = (1u << 8),
	GIT_STATUS_OPT_SORT_CASE_SENSITIVELY            = (1u << 9),
	GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY          = (1u << 10),
	GIT_STATUS_OPT_RENAMES_FROM_REWRITES            = (1u << 11),
	GIT_STATUS_OPT_NO_REFRESH                       = (1u << 12),
	GIT_STATUS_OPT_UPDATE_INDEX                     = (1u << 13),
	GIT_STATUS_OPT_INCLUDE_UNREADABLE               = (1u << 14),
	GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED  = (1u << 15),
} git_status_opt_t;
*)
const
  GIT_STATUS_OPT_INCLUDE_UNTRACKED                = $00000001;
  GIT_STATUS_OPT_INCLUDE_IGNORED                  = $00000002;
  GIT_STATUS_OPT_INCLUDE_UNMODIFIED               = $00000004;
  GIT_STATUS_OPT_EXCLUDE_SUBMODULES               = $00000008;
  GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS           = $00000010;
  GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH           = $00000020;
  GIT_STATUS_OPT_RECURSE_IGNORED_DIRS             = $00000040;
  GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX            = $00000080;
  GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR         = $00000100;
  GIT_STATUS_OPT_SORT_CASE_SENSITIVELY            = $00000200;
  GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY          = $00000400;
  GIT_STATUS_OPT_RENAMES_FROM_REWRITES            = $00000800;
  GIT_STATUS_OPT_NO_REFRESH                       = $00001000;
  GIT_STATUS_OPT_UPDATE_INDEX                     = $00002000;
  GIT_STATUS_OPT_INCLUDE_UNREADABLE               = $00004000;
  GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED  = $00008000;

///**
// * Options to control how `git_status_foreach_ext()` will issue callbacks.
// *
// * This structure is set so that zeroing it out will give you relatively
// * sane defaults.
// *
// * The `show` value is one of the `git_status_show_t` constants that
// * control which files to scan and in what order.
// *
// * The `flags` value is an OR'ed combination of the `git_status_opt_t`
// * values above.
// *
// * The `pathspec` is an array of path patterns to match (using
// * fnmatch-style matching), or just an array of paths to match exactly if
// * `GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH` is specified in the flags.
// */
//typedef struct {
//	unsigned int      version;
//	git_status_show_t show;
//	unsigned int      flags;
//	git_strarray      pathspec;
//} git_status_options;

//typedef struct git_strarray {
//	char **strings;
//	size_t count;
//} git_strarray;


type
  pgit_status_options = ^git_status_options;
  git_status_options = record
    version :uint;
    show :uint; {git_status_show_t;}
    flags :uint;
    pathspec :git_strarray;
  end;


(*
/**
 * What type of change is described by a git_diff_delta?
 *
 * `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run
 * `git_diff_find_similar()` on the diff object.
 *
 * `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE`
 * in the option flags (otherwise type changes will be split into ADDED /
 * DELETED pairs).
 */
typedef enum {
	GIT_DELTA_UNMODIFIED = 0,  /**< no changes */
	GIT_DELTA_ADDED = 1,	   /**< entry does not exist in old version */
	GIT_DELTA_DELETED = 2,	   /**< entry does not exist in new version */
	GIT_DELTA_MODIFIED = 3,    /**< entry content changed between old and new */
	GIT_DELTA_RENAMED = 4,     /**< entry was renamed between old and new */
	GIT_DELTA_COPIED = 5,      /**< entry was copied from another old entry */
	GIT_DELTA_IGNORED = 6,     /**< entry is ignored item in workdir */
	GIT_DELTA_UNTRACKED = 7,   /**< entry is untracked item in workdir */
	GIT_DELTA_TYPECHANGE = 8,  /**< type of entry changed between old and new */
	GIT_DELTA_UNREADABLE = 9,  /**< entry is unreadable */
	GIT_DELTA_CONFLICTED = 10, /**< entry in the index is conflicted */
} git_delta_t;
*)
const
  GIT_DELTA_UNMODIFIED = 0;  { no changes }
  GIT_DELTA_ADDED = 1;	     { entry does not exist in old version }
  GIT_DELTA_DELETED = 2;     { entry does not exist in new version }
  GIT_DELTA_MODIFIED = 3;    { entry content changed between old and new }
  GIT_DELTA_RENAMED = 4;     { entry was renamed between old and new }
  GIT_DELTA_COPIED = 5;      { entry was copied from another old entry }
  GIT_DELTA_IGNORED = 6;     { entry is ignored item in workdir }
  GIT_DELTA_UNTRACKED = 7;   { entry is untracked item in workdir }
  GIT_DELTA_TYPECHANGE = 8;  { type of entry changed between old and new }
  GIT_DELTA_UNREADABLE = 9;  { entry is unreadable }
  GIT_DELTA_CONFLICTED = 10; { entry in the index is conflicted }


(*
typedef enum {
	GIT_STATUS_CURRENT = 0,

	GIT_STATUS_INDEX_NEW        = (1u << 0),
	GIT_STATUS_INDEX_MODIFIED   = (1u << 1),
	GIT_STATUS_INDEX_DELETED    = (1u << 2),
	GIT_STATUS_INDEX_RENAMED    = (1u << 3),
	GIT_STATUS_INDEX_TYPECHANGE = (1u << 4),

	GIT_STATUS_WT_NEW           = (1u << 7),
	GIT_STATUS_WT_MODIFIED      = (1u << 8),
	GIT_STATUS_WT_DELETED       = (1u << 9),
	GIT_STATUS_WT_TYPECHANGE    = (1u << 10),
	GIT_STATUS_WT_RENAMED       = (1u << 11),
	GIT_STATUS_WT_UNREADABLE    = (1u << 12),

	GIT_STATUS_IGNORED          = (1u << 14),
	GIT_STATUS_CONFLICTED       = (1u << 15),
} git_status_t;
*)
const
  {git_status_t}
  GIT_STATUS_CURRENT               = 0;

  { Flags for index status }
  GIT_STATUS_INDEX_NEW             = 1 shl 0;
  GIT_STATUS_INDEX_MODIFIED        = 1 shl 1;
  GIT_STATUS_INDEX_DELETED         = 1 shl 2;
  GIT_STATUS_INDEX_RENAMED         = 1 shl 3;
  GIT_STATUS_INDEX_TYPECHANGE      = 1 shl 4;

  { Flags for worktree status }
  GIT_STATUS_WT_NEW                = 1 shl 7;
  GIT_STATUS_WT_MODIFIED           = 1 shl 8;
  GIT_STATUS_WT_DELETED            = 1 shl 9;

  GIT_STATUS_IGNORED               = 1 shl 14;

(*
/**
 * Possible output formats for diff data
 */
typedef enum {
	GIT_DIFF_FORMAT_PATCH        = 1u, /**< full git diff */
	GIT_DIFF_FORMAT_PATCH_HEADER = 2u, /**< just the file headers of patch */
	GIT_DIFF_FORMAT_RAW          = 3u, /**< like git diff --raw */
	GIT_DIFF_FORMAT_NAME_ONLY    = 4u, /**< like git diff --name-only */
	GIT_DIFF_FORMAT_NAME_STATUS  = 5u, /**< like git diff --name-status */
} git_diff_format_t;
*)
const
  { git_diff_format_t }
  GIT_DIFF_FORMAT_PATCH        = 1; { full git diff }
  GIT_DIFF_FORMAT_PATCH_HEADER = 2; { just the file headers of patch }
  GIT_DIFF_FORMAT_RAW          = 3; { like git diff --raw }
  GIT_DIFF_FORMAT_NAME_ONLY    = 4; { like git diff --name-only }
  GIT_DIFF_FORMAT_NAME_STATUS  = 5; { like git diff --name-status }


(* git_diff_option_t
/**
 * Flags for diff options.  A combination of these flags can be passed
 * in via the `flags` value in the `git_diff_options`.
 */
typedef enum {
	/** Normal diff, the default */
	GIT_DIFF_NORMAL = 0,

	/*
	 * Options controlling which files will be in the diff
	 */

	/** Reverse the sides of the diff */
	GIT_DIFF_REVERSE = (1u << 0),

	/** Include ignored files in the diff */
	GIT_DIFF_INCLUDE_IGNORED = (1u << 1),

	/** Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory
	 *  will be marked with only a single entry in the diff; this flag
	 *  adds all files under the directory as IGNORED entries, too.
	 */
	GIT_DIFF_RECURSE_IGNORED_DIRS = (1u << 2),

	/** Include untracked files in the diff */
	GIT_DIFF_INCLUDE_UNTRACKED = (1u << 3),

	/** Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked
	 *  directory will be marked with only a single entry in the diff
	 *  (a la what core Git does in `git status`); this flag adds *all*
	 *  files under untracked directories as UNTRACKED entries, too.
	 */
	GIT_DIFF_RECURSE_UNTRACKED_DIRS = (1u << 4),

	/** Include unmodified files in the diff */
	GIT_DIFF_INCLUDE_UNMODIFIED = (1u << 5),

	/** Normally, a type change between files will be converted into a
	 *  DELETED record for the old and an ADDED record for the new; this
	 *  options enabled the generation of TYPECHANGE delta records.
	 */
	GIT_DIFF_INCLUDE_TYPECHANGE = (1u << 6),

	/** Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still
	 *  generally show as a DELETED blob.  This flag tries to correctly
	 *  label blob->tree transitions as TYPECHANGE records with new_file's
	 *  mode set to tree.  Note: the tree SHA will not be available.
	 */
	GIT_DIFF_INCLUDE_TYPECHANGE_TREES = (1u << 7),

	/** Ignore file mode changes */
	GIT_DIFF_IGNORE_FILEMODE = (1u << 8),

	/** Treat all submodules as unmodified */
	GIT_DIFF_IGNORE_SUBMODULES = (1u << 9),

	/** Use case insensitive filename comparisons */
	GIT_DIFF_IGNORE_CASE = (1u << 10),

	/** May be combined with `GIT_DIFF_IGNORE_CASE` to specify that a file
	 *  that has changed case will be returned as an add/delete pair.
	 */
	GIT_DIFF_INCLUDE_CASECHANGE = (1u << 11),

	/** If the pathspec is set in the diff options, this flags indicates
	 *  that the paths will be treated as literal paths instead of
	 *  fnmatch patterns.  Each path in the list must either be a full
	 *  path to a file or a directory.  (A trailing slash indicates that
	 *  the path will _only_ match a directory).  If a directory is
	 *  specified, all children will be included.
	 */
	GIT_DIFF_DISABLE_PATHSPEC_MATCH = (1u << 12),

	/** Disable updating of the `binary` flag in delta records.  This is
	 *  useful when iterating over a diff if you don't need hunk and data
	 *  callbacks and want to avoid having to load file completely.
	 */
	GIT_DIFF_SKIP_BINARY_CHECK = (1u << 13),

	/** When diff finds an untracked directory, to match the behavior of
	 *  core Git, it scans the contents for IGNORED and UNTRACKED files.
	 *  If *all* contents are IGNORED, then the directory is IGNORED; if
	 *  any contents are not IGNORED, then the directory is UNTRACKED.
	 *  This is extra work that may not matter in many cases.  This flag
	 *  turns off that scan and immediately labels an untracked directory
	 *  as UNTRACKED (changing the behavior to not match core Git).
	 */
	GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = (1u << 14),

	/** When diff finds a file in the working directory with stat
	 * information different from the index, but the OID ends up being the
	 * same, write the correct stat information into the index.  Note:
	 * without this flag, diff will always leave the index untouched.
	 */
	GIT_DIFF_UPDATE_INDEX = (1u << 15),

	/** Include unreadable files in the diff */
	GIT_DIFF_INCLUDE_UNREADABLE = (1u << 16),

	/** Include unreadable files in the diff */
	GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = (1u << 17),

	/*
	 * Options controlling how output will be generated
	 */

	/** Treat all files as text, disabling binary attributes & detection */
	GIT_DIFF_FORCE_TEXT = (1u << 20),
	/** Treat all files as binary, disabling text diffs */
	GIT_DIFF_FORCE_BINARY = (1u << 21),

	/** Ignore all whitespace */
	GIT_DIFF_IGNORE_WHITESPACE = (1u << 22),
	/** Ignore changes in amount of whitespace */
	GIT_DIFF_IGNORE_WHITESPACE_CHANGE = (1u << 23),
	/** Ignore whitespace at end of line */
	GIT_DIFF_IGNORE_WHITESPACE_EOL = (1u << 24),

	/** When generating patch text, include the content of untracked
	 *  files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but
	 *  it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that
	 *  flag if you want the content of every single UNTRACKED file.
	 */
	GIT_DIFF_SHOW_UNTRACKED_CONTENT = (1u << 25),

	/** When generating output, include the names of unmodified files if
	 *  they are included in the git_diff.  Normally these are skipped in
	 *  the formats that list files (e.g. name-only, name-status, raw).
	 *  Even with this, these will not be included in patch format.
	 */
	GIT_DIFF_SHOW_UNMODIFIED = (1u << 26),

	/** Use the "patience diff" algorithm */
	GIT_DIFF_PATIENCE = (1u << 28),
	/** Take extra time to find minimal diff */
	GIT_DIFF_MINIMAL = (1 << 29),

	/** Include the necessary deflate / delta information so that `git-apply`
	 *  can apply given diff information to binary files.
	 */
	GIT_DIFF_SHOW_BINARY = (1 << 30),
} git_diff_option_t;
*)
  const
    {git_diff_option_t}
    GIT_DIFF_NORMAL = 0;
    GIT_DIFF_REVERSE = 1 shl 0;
    GIT_DIFF_INCLUDE_IGNORED = 1 shl 1;
    GIT_DIFF_RECURSE_IGNORED_DIRS = 1 shl 2;
    GIT_DIFF_INCLUDE_UNTRACKED = 1 shl 3;
    GIT_DIFF_RECURSE_UNTRACKED_DIRS = 1 shl 4;
    GIT_DIFF_INCLUDE_UNMODIFIED = 1 shl 5;
    GIT_DIFF_INCLUDE_TYPECHANGE = 1 shl 6;
    GIT_DIFF_INCLUDE_TYPECHANGE_TREES = 1 shl 7;
    GIT_DIFF_IGNORE_FILEMODE = 1 shl 8;
    GIT_DIFF_IGNORE_SUBMODULES = 1 shl 9;
    GIT_DIFF_IGNORE_CASE = 1 shl 10;
    GIT_DIFF_INCLUDE_CASECHANGE = 1 shl 11;
    GIT_DIFF_DISABLE_PATHSPEC_MATCH = 1 shl 12;
    GIT_DIFF_SKIP_BINARY_CHECK = 1 shl 13;
    GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = 1 shl 14;
    GIT_DIFF_UPDATE_INDEX = 1 shl 15;
    GIT_DIFF_INCLUDE_UNREADABLE = 1 shl 16;
    GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = 1 shl 17;

    GIT_DIFF_FORCE_TEXT = 1 shl 20;
    GIT_DIFF_FORCE_BINARY = 1 shl 21;
    GIT_DIFF_IGNORE_WHITESPACE = 1 shl 22;
    GIT_DIFF_IGNORE_WHITESPACE_CHANGE = 1 shl 23;
    GIT_DIFF_IGNORE_WHITESPACE_EOL = 1 shl 24;
    GIT_DIFF_SHOW_UNTRACKED_CONTENT = 1 shl 25;
    GIT_DIFF_SHOW_UNMODIFIED = 1 shl 26;
    GIT_DIFF_PATIENCE = 1 shl 28;
    GIT_DIFF_MINIMAL = 1 shl 29;
    GIT_DIFF_SHOW_BINARY = 1 shl 30;

(* git_diff_options
/**
 * Structure describing options about how the diff should be executed.
 *
 * Setting all values of the structure to zero will yield the default
 * values.  Similarly, passing NULL for the options structure will
 * give the defaults.  The default values are marked below.
 *
 * - `flags` is a combination of the `git_diff_option_t` values above
 * - `context_lines` is the number of unchanged lines that define the
 *    boundary of a hunk (and to display before and after)
 * - `interhunk_lines` is the maximum number of unchanged lines between
 *    hunk boundaries before the hunks will be merged into a one.
 * - `old_prefix` is the virtual "directory" to prefix to old file names
 *   in hunk headers (default "a")
 * - `new_prefix` is the virtual "directory" to prefix to new file names
 *   in hunk headers (default "b")
 * - `pathspec` is an array of paths / fnmatch patterns to constrain diff
 * - `max_size` is a file size (in bytes) above which a blob will be marked
 *   as binary automatically; pass a negative value to disable.
 * - `notify_cb` is an optional callback function, notifying the consumer of
 *   changes to the diff as new deltas are added.
 * - `progress_cb` is an optional callback function, notifying the consumer of
 *   which files are being examined as the diff is generated.
 * - `payload` is the payload to pass to the callback functions.
 * - `ignore_submodules` overrides the submodule ignore setting for all
 *   submodules in the diff.
 */
typedef struct {
	unsigned int version;      /**< version for the struct */
	uint32_t flags;            /**< defaults to GIT_DIFF_NORMAL */

	/* options controlling which files are in the diff */

	git_submodule_ignore_t ignore_submodules; /**< submodule ignore rule */
	git_strarray       pathspec;     /**< defaults to include all paths */
	git_diff_notify_cb   notify_cb;
	git_diff_progress_cb progress_cb;
	void                *payload;

	/* options controlling how to diff text is generated */

	uint32_t    context_lines;    /**< defaults to 3 */
	uint32_t    interhunk_lines;  /**< defaults to 0 */
	uint16_t    id_abbrev;       /**< default 'core.abbrev' or 7 if unset */
	git_off_t   max_size;         /**< defaults to 512MB */
	const char *old_prefix;       /**< defaults to "a" */
	const char *new_prefix;       /**< defaults to "b" */
} git_diff_options;
*)
type
  git_diff_options = record
    version :uint;
    flags :uint32_t; {set of git_diff_option_t}

    ignore_submodules :uint; {git_submodule_ignore_t}
    pathspec :git_strarray;

    notify_cb :pointer; {git_diff_notify_cb}
    progress_cb :pointer; {git_diff_progress_cb}
    payload :pointer;

    context_lines :uint32_t;
    interhunk_lines :uint32_t;
    id_abbrev :uint16_t;
    max_size :git_off_t;
    old_prefix :PAnsiChar;
    new_prefix :PAnsiChar;
  end;
  TGitDiffOptions = git_diff_options;
  PGitDiffOptions = ^TGitDiffOptions;


(*
typedef struct {
	git_oid     id;
	const char *path;
	git_off_t   size;
	uint32_t    flags;
	uint16_t    mode;
	uint16_t    id_abbrev;
} git_diff_file;

typedef struct {
	git_delta_t   status;
	uint32_t      flags;	   /**< git_diff_flag_t values */
	uint16_t      similarity;  /**< for RENAMED and COPIED, value 0-100 */
	uint16_t      nfiles;	   /**< number of files in this delta */
	git_diff_file old_file;
	git_diff_file new_file;
} git_diff_delta;

typedef struct {
	git_status_t status;
	git_diff_delta *head_to_index;
	git_diff_delta *index_to_workdir;
} git_status_entry;
*)

type
  git_diff_file = record
    id         :git_oid;
    path       :PAnsiChar;
    size       :git_off_t;
    flags      :uint32_t;
    mode       :uint16_t;
    id_abbrev  :uint16_t;
  end;
  TGitDiffFile = git_diff_file;
  PGitDiffFile = ^TGitDiffFile;

  git_diff_delta = record
    status     :uint; {git_delta_t}
    flags      :uint32_t;               { git_diff_flag_t values }
    similarity :uint16_t;               { for RENAMED and COPIED, value 0-100 }
    nfiles     :uint16_t;               { number of files in this delta }
    old_file   :git_diff_file;
    new_file   :git_diff_file;
  end;
  TGitDiffDelta = git_diff_delta;
  PGitDiffDelta = ^TGitDiffDelta;

  git_status_entry = record
    status :uint {git_status_t};
    head_to_index :PGitDiffDelta;
    index_to_workdir :PGitDiffDelta;
  end;
  TGitStatusEntry = git_status_entry;
  PGitStatusEntry = ^TGitStatusEntry;


(* git_checkout_strategy_t
/**
 * Checkout behavior flags
 *
 * In libgit2, checkout is used to update the working directory and index
 * to match a target tree.  Unlike git checkout, it does not move the HEAD
 * commit for you - use `git_repository_set_head` or the like to do that.
 *
 * Checkout looks at (up to) four things: the "target" tree you want to
 * check out, the "baseline" tree of what was checked out previously, the
 * working directory for actual files, and the index for staged changes.
 *
 * You give checkout one of three strategies for update:
 *
 * - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts,
 *   etc., but doesn't make any actual changes.
 *
 * - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to
 *   make the working directory match the target (including potentially
 *   discarding modified files).
 *
 * - `GIT_CHECKOUT_SAFE` is between these two options, it will only make
 *   modifications that will not lose changes.
 *
 *                         |  target == baseline   |  target != baseline  |
 *    ---------------------|-----------------------|----------------------|
 *     workdir == baseline |       no action       |  create, update, or  |
 *                         |                       |     delete file      |
 *    ---------------------|-----------------------|----------------------|
 *     workdir exists and  |       no action       |   conflict (notify   |
 *       is != baseline    | notify dirty MODIFIED | and cancel checkout) |
 *    ---------------------|-----------------------|----------------------|
 *      workdir missing,   | notify dirty DELETED  |     create file      |
 *      baseline present   |                       |                      |
 *    ---------------------|-----------------------|----------------------|
 *
 * To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout
 * notification callback (see below) that displays information about dirty
 * files.  The default behavior will cancel checkout on conflicts.
 *
 * To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a
 * notification callback that cancels the operation if a dirty-but-existing
 * file is found in the working directory.  This core git command isn't
 * quite "force" but is sensitive about some types of changes.
 *
 * To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`.
 *
 *
 * There are some additional flags to modified the behavior of checkout:
 *
 * - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates
 *   even if there are conflicts (instead of cancelling the checkout).
 *
 * - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not
 *   in target, baseline, or index, and not ignored) from the working dir.
 *
 * - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also
 *   untracked) from the working directory as well.
 *
 * - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that
 *   already exist.  Files will not be created nor deleted.  This just skips
 *   applying adds, deletes, and typechanges.
 *
 * - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the
 *   updated files' information to the index.
 *
 * - Normally, checkout will reload the index and git attributes from disk
 *   before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload.
 *
 * - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips
 *   files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and
 *   GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the
 *   stage 2 ("ours") or stage 3 ("theirs") version of files in the index.
 *
 * - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being
 *   overwritten.  Normally, files that are ignored in the working directory
 *   are not considered "precious" and may be overwritten if the checkout
 *   target contains that file.
 *
 * - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing
 *   files or folders that fold to the same name on case insensitive
 *   filesystems.  This can cause files to retain their existing names
 *   and write through existing symbolic links.
 */
typedef enum {
	GIT_CHECKOUT_NONE = 0, /**< default is a dry run, no actual updates */

	/** Allow safe updates that cannot overwrite uncommitted data */
	GIT_CHECKOUT_SAFE = (1u << 0),

	/** Allow all updates to force working directory to look like index */
	GIT_CHECKOUT_FORCE = (1u << 1),


	/** Allow checkout to recreate missing files */
	GIT_CHECKOUT_RECREATE_MISSING = (1u << 2),

	/** Allow checkout to make safe updates even if conflicts are found */
	GIT_CHECKOUT_ALLOW_CONFLICTS = (1u << 4),

	/** Remove untracked files not in index (that are not ignored) */
	GIT_CHECKOUT_REMOVE_UNTRACKED = (1u << 5),

	/** Remove ignored files not in index */
	GIT_CHECKOUT_REMOVE_IGNORED = (1u << 6),

	/** Only update existing files, don't create new ones */
	GIT_CHECKOUT_UPDATE_ONLY = (1u << 7),

	/**
	 * Normally checkout updates index entries as it goes; this stops that.
	 * Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
	 */
	GIT_CHECKOUT_DONT_UPDATE_INDEX = (1u << 8),

	/** Don't refresh index/config/etc before doing checkout */
	GIT_CHECKOUT_NO_REFRESH = (1u << 9),

	/** Allow checkout to skip unmerged files */
	GIT_CHECKOUT_SKIP_UNMERGED = (1u << 10),
	/** For unmerged files, checkout stage 2 from index */
	GIT_CHECKOUT_USE_OURS = (1u << 11),
	/** For unmerged files, checkout stage 3 from index */
	GIT_CHECKOUT_USE_THEIRS = (1u << 12),

	/** Treat pathspec as simple list of exact match file paths */
	GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = (1u << 13),

	/** Ignore directories in use, they will be left empty */
	GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = (1u << 18),

	/** Don't overwrite ignored files that exist in the checkout target */
	GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = (1u << 19),

	/** Write normal merge files for conflicts */
	GIT_CHECKOUT_CONFLICT_STYLE_MERGE = (1u << 20),

	/** Include common ancestor data in diff3 format files for conflicts */
	GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = (1u << 21),

	/** Don't overwrite existing files or folders */
	GIT_CHECKOUT_DONT_REMOVE_EXISTING = (1u << 22),

	/** Normally checkout writes the index upon completion; this prevents that. */
	GIT_CHECKOUT_DONT_WRITE_INDEX = (1u << 23),

	/**
	 * THE FOLLOWING OPTIONS ARE NOT YET IMPLEMENTED
	 */

	/** Recursively checkout submodules with same options (NOT IMPLEMENTED) */
	GIT_CHECKOUT_UPDATE_SUBMODULES = (1u << 16),
	/** Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED) */
	GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = (1u << 17),

} git_checkout_strategy_t;
*)
const
  GIT_CHECKOUT_NONE = 0;
  GIT_CHECKOUT_SAFE = 1 shl 0;
  GIT_CHECKOUT_FORCE = 1 shl 1;
  GIT_CHECKOUT_RECREATE_MISSING = 1 shl 2;
  GIT_CHECKOUT_ALLOW_CONFLICTS = 1 shl 4;
  GIT_CHECKOUT_REMOVE_UNTRACKED = 1 shl 5;
  GIT_CHECKOUT_REMOVE_IGNORED = 1 shl 6;
  GIT_CHECKOUT_UPDATE_ONLY = 1 shl 7;
  GIT_CHECKOUT_DONT_UPDATE_INDEX = 1 shl 8;
  GIT_CHECKOUT_NO_REFRESH = 1 shl 9;
  GIT_CHECKOUT_SKIP_UNMERGED = 1 shl 10;
  GIT_CHECKOUT_USE_OURS = 1 shl 11;
  GIT_CHECKOUT_USE_THEIRS = 1 shl 12;
  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = 1 shl 13;
  GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = 1 shl 18;
  GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = 1 shl 19;
  GIT_CHECKOUT_CONFLICT_STYLE_MERGE = 1 shl 20;
  GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = 1 shl 21;
  GIT_CHECKOUT_DONT_REMOVE_EXISTING = 1 shl 22;
  GIT_CHECKOUT_DONT_WRITE_INDEX = 1 shl 23;
  GIT_CHECKOUT_UPDATE_SUBMODULES = 1 shl 16;
  GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = 1 shl 17;


(*
/** Checkout notification callback function */
typedef int (*git_checkout_notify_cb)(
	git_checkout_notify_t why,
	const char *path,
	const git_diff_file *baseline,
	const git_diff_file *target,
	const git_diff_file *workdir,
	void *payload);
*)
type
  git_checkout_notify_cb = function(why :uint; path :PAnsiChar; baseline, target, workdir :PGitDiffFile; payload :pointer) :Integer; cdecl;


(* git_checkout_options
/**
 * Checkout options structure
 *
 * Zero out for defaults.  Initialize with `GIT_CHECKOUT_OPTIONS_INIT` macro to
 * correctly set the `version` field.  E.g.
 *
 *		git_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;
 */
typedef struct git_checkout_options {
	unsigned int version;

	unsigned int checkout_strategy; /**< default will be a dry run */

	int disable_filters;    /**< don't apply filters like CRLF conversion */
	unsigned int dir_mode;  /**< default is 0755 */
	unsigned int file_mode; /**< default is 0644 or 0755 as dictated by blob */
	int file_open_flags;    /**< default is O_CREAT | O_TRUNC | O_WRONLY */

	unsigned int notify_flags; /**< see `git_checkout_notify_t` above */
	git_checkout_notify_cb notify_cb;
	void *notify_payload;

	/** Optional callback to notify the consumer of checkout progress. */
	git_checkout_progress_cb progress_cb;
	void *progress_payload;

	/** When not zeroed out, array of fnmatch patterns specifying which
	 *  paths should be taken into account, otherwise all files.  Use
	 *  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as simple list.
	 */
	git_strarray paths;

	/** The expected content of the working directory; defaults to HEAD.
	 *  If the working directory does not match this baseline information,
	 *  that will produce a checkout conflict.
	 */
	git_tree *baseline;

	/** Like `baseline` above, though expressed as an index.  This
	 *  option overrides `baseline`.
	 */
	git_index *baseline_index; /**< expected content of workdir, expressed as an index. */

	const char *target_directory; /**< alternative checkout path to workdir */

	const char *ancestor_label; /**< the name of the common ancestor side of conflicts */
	const char *our_label; /**< the name of the "our" side of conflicts */
	const char *their_label; /**< the name of the "their" side of conflicts */

	/** Optional callback to notify the consumer of performance data. */
	git_checkout_perfdata_cb perfdata_cb;
	void *perfdata_payload;
} git_checkout_options;
*)

type
  git_checkout_options = record
    version            :uint;
    checkout_strategy  :uint;  {set of git_checkout_strategy_t}

    disable_filters    :int;
    dir_mode           :uint;
    file_mode          :uint;
    file_open_flags    :int;

    notify_flags       :uint;
    notify_cb          :git_checkout_notify_cb;
    notify_payload     :pointer;

    progress_cb        :pointer; {git_checkout_progress_cb}
    progress_payload   :pointer;

    paths              :git_strarray;

    baseline           :PGitTree;

    baseline_index     :PGitIndex;

    target_directory   :PAnsiChar;

    ancestor_label     :PAnsiChar;
    our_label          :PAnsiChar;
    their_label        :PAnsiChar;

    perfdata_cb        :pointer; {git_checkout_perfdata_cb}
    perfdata_payload   :pointer;
  end;
  TGitCheckoutOptions = git_checkout_options;
  PGitCheckoutOptions = ^TGitCheckoutOptions;


(* git_branch_t
/** Basic type of any Git branch. */
typedef enum {
	GIT_BRANCH_LOCAL = 1,
	GIT_BRANCH_REMOTE = 2,
	GIT_BRANCH_ALL = GIT_BRANCH_LOCAL|GIT_BRANCH_REMOTE,
} git_branch_t;
*)
const
  GIT_BRANCH_LOCAL = 1;
  GIT_BRANCH_REMOTE = 2;
  GIT_BRANCH_ALL = GIT_BRANCH_LOCAL or GIT_BRANCH_REMOTE;



(*

/**

 * Options controlling how pathspec match should be executed
 *
 * - GIT_PATHSPEC_IGNORE_CASE forces match to ignore case; otherwise
 *   match will use native case sensitivity of platform filesystem
 * - GIT_PATHSPEC_USE_CASE forces case sensitive match; otherwise
 *   match will use native case sensitivity of platform filesystem
 * - GIT_PATHSPEC_NO_GLOB disables glob patterns and just uses simple
 *   string comparison for matching
 * - GIT_PATHSPEC_NO_MATCH_ERROR means the match functions return error
 *   code GIT_ENOTFOUND if no matches are found; otherwise no matches is
 *   still success (return 0) but `git_pathspec_match_list_entrycount`
 *   will indicate 0 matches.
 * - GIT_PATHSPEC_FIND_FAILURES means that the `git_pathspec_match_list`
 *   should track which patterns matched which files so that at the end of
 *   the match we can identify patterns that did not match any files.
 * - GIT_PATHSPEC_FAILURES_ONLY means that the `git_pathspec_match_list`
 *   does not need to keep the actual matching filenames.  Use this to
 *   just test if there were any matches at all or in combination with
 *   GIT_PATHSPEC_FIND_FAILURES to validate a pathspec.
 */
typedef enum {
	GIT_PATHSPEC_DEFAULT        = 0,
	GIT_PATHSPEC_IGNORE_CASE    = (1u << 0),
	GIT_PATHSPEC_USE_CASE       = (1u << 1),
	GIT_PATHSPEC_NO_GLOB        = (1u << 2),
	GIT_PATHSPEC_NO_MATCH_ERROR = (1u << 3),
	GIT_PATHSPEC_FIND_FAILURES  = (1u << 4),
	GIT_PATHSPEC_FAILURES_ONLY  = (1u << 5),
} git_pathspec_flag_t;
*)

const

  GIT_PATHSPEC_DEFAULT        = 0;

  GIT_PATHSPEC_IGNORE_CASE    = 1 shl 0;
  GIT_PATHSPEC_USE_CASE       = 1 shl 1;
  GIT_PATHSPEC_NO_GLOB        = 1 shl 2;
  GIT_PATHSPEC_NO_MATCH_ERROR = 1 shl 3;
  GIT_PATHSPEC_FIND_FAILURES  = 1 shl 4;
  GIT_PATHSPEC_FAILURES_ONLY  = 1 shl 5;


(*
/**
 * When iterating over a diff, callback that will be made per text diff
 * line. In this context, the provided range will be NULL.
 *
 * When printing a diff, callback that will be made to output each line
 * of text.  This uses some extra GIT_DIFF_LINE_... constants for output
 * of lines of file and hunk headers.
 */
typedef int (*git_diff_line_cb)(
	const git_diff_delta *delta, /**< delta that contains this data */
	const git_diff_hunk *hunk,   /**< hunk containing this data */
	const git_diff_line *line,   /**< line data */
	void *payload);              /**< user reference data */
*)
type
  git_diff_line_cb = function(delta :PGitDiffDelta; hunk :pointer{Pgit_diff_hunk}; line :pointer{Pgit_diff_line}; payload :pointer): Integer; cdecl;

  //int git_diff_file_cb(const git_diff_delta *delta, float progress, void *payload);
  git_diff_file_cb = function(delta :PGitDiffDelta; progress :float; payload :pointer) :integer; cdecl;

  //typedef int (*git_tag_foreach_cb)(const char *name, git_oid *oid, void *payload);
  git_tag_foreach_cb = function(name :PAnsiChar; oid :PGitOID; payload :pointer) :integer; cdecl;


var
  //  int git_libgit2_init();
  git_libgit2_init :function :Integer; cdecl;

  // int git_libgit2_shutdown();
  git_libgit2_shutdown :function :Integer; cdecl;

  //----------------------------------------------------------------------------
  // repository

  // GIT_EXTERN(int) git_repository_open(git_repository **repository, const char *path);
  git_repository_open :function(var repo_out: PGitRepository; const path: PGitChar): Integer; cdecl;

  // int git_repository_open_ext(git_repository **out, const char *path, unsigned int flags, const char *ceiling_dirs);
  git_repository_open_ext :function (var repo_out: PGitRepository; const path: PGitChar; flags :uint; ceiling_dirs :PGitChar): Integer; cdecl;

  // int git_repository_head(git_reference **out, git_repository *repo);
  git_repository_head :function(var head_out :PGitReference; repo :PGitRepository) :Integer; cdecl;

  //int git_repository_head_detached(git_repository *repo);
  git_repository_head_detached :function(repo: PGitRepository) :Integer; cdecl;

  //int git_repository_head_unborn(git_repository *repo);
  git_repository_head_unborn :function(repo: PGitRepository) :Integer; cdecl;

  // const char * git_repository_workdir(git_repository *repo);
  git_repository_workdir :function(repo: PGitRepository) :PAnsiChar; cdecl;

  //int git_repository_set_head(git_repository *repo, const char *refname);
  git_repository_set_head :function(repo :PGitRepository; refname :PAnsiChar) :Integer; cdecl;

  // int git_repository_set_head_detached(git_repository *repo, const git_oid *commitish);
  git_repository_set_head_detached :function(repo :PGitRepository; commitish :PGitOid) :Integer; cdecl;

  //int git_repository_set_head_detached_from_annotated(git_repository *repo, const git_annotated_commit *commitish);
  git_repository_set_head_detached_from_annotated :function(repo :PGitRepository; commitish :PGitAnnotCommit) :Integer; cdecl;

  // GIT_EXTERN(void) git_repository_free(git_repository *repo);
  git_repository_free :procedure (repo: PGitRepository); cdecl;


  //----------------------------------------------------------------------------
  // Status

  // int git_status_foreach(git_repository *repo, git_status_cb callback, void *payload);
  git_status_foreach :function(repo: PGitRepository; callback: Pgit_status_foreach_callback; payload: PByte): Integer; cdecl;

  //  int git_status_foreach_ext(git_repository *repo, const git_status_options *opts, git_status_cb callback, void *payload);
  git_status_foreach_ext :function(repo: PGitRepository; opt :pgit_status_options; callback: Pgit_status_foreach_callback; payload: PByte): Integer; cdecl;

  // int git_status_list_new(git_status_list **out, git_repository *repo, const git_status_options *opts);
  git_status_list_new :function(var statuslist :PGitStatusList; repo :PGitRepository; opt :pgit_status_options) :Integer; cdecl;

  // void git_status_list_free(git_status_list *statuslist);
  git_status_list_free :procedure(statuslist :PGitStatusList); cdecl;

  //size_t git_status_list_entrycount(git_status_list *statuslist);
  git_status_list_entrycount :function(statuslist :PGitStatusList) :size_t; cdecl;

  // const git_status_entry * git_status_byindex(git_status_list *statuslist, size_t idx);
  git_status_byindex :function(statuslist :PGitStatusList; idx :size_t) :PGitStatusEntry; cdecl;

  //----------------------------------------------------------------------------
  // Reference

  //const char * git_reference_name(const git_reference *ref);
  git_reference_name :function(ref :PGitReference) :PAnsiChar; cdecl;

  //int git_reference_name_to_id(git_oid *out, git_repository *repo, const char *name);
  git_reference_name_to_id :function(var oid :TGitOID; repo :PGitRepository; name :PAnsiChar) :integer; cdecl;

  // const char * git_reference_shorthand(const git_reference *ref);
  git_reference_shorthand :function(ref :PGitReference) :PAnsiChar; cdecl;

  //const char * git_reference_symbolic_target(const git_reference *ref);
  git_reference_symbolic_target :function(ref :PGitReference) :PAnsiChar; cdecl;

  //int git_reference_lookup(git_reference **out, git_repository *repo, const char *name);
  git_reference_lookup :function(var ref_out :PGitReference; repo :PGitRepository; name :PAnsiChar) :Integer; cdecl;

  //int git_reference_dwim(git_reference **out, git_repository *repo, const char *shorthand);
  git_reference_dwim :function(var ref_out :PGitReference; repo :PGitRepository; shorthand :PAnsiChar) :Integer; cdecl;

  //int git_reference_is_branch(const git_reference *ref);
  git_reference_is_branch :function(ref :PGitReference) :Integer; cdecl;

  //int git_reference_is_remote(const git_reference *ref);
  git_reference_is_remote :function(ref :PGitReference) :Integer; cdecl;

  //int git_reference_is_tag(const git_reference *ref);
  git_reference_is_tag :function(ref :PGitReference) :Integer; cdecl;

  //const git_oid * git_reference_target(const git_reference *ref);
  git_reference_target :function(ref :PGitReference) :PGitOid; cdecl;

  // void git_reference_free(git_reference *ref);
  git_reference_free :procedure(ref :PGitReference); cdecl;

  //---------------------------------------------------------------------------
  // Objects

  //int git_revparse_single(git_object **out, git_repository *repo, const char *spec);
  git_revparse_single :function(var obj_out :PGitObject; repo: PGitRepository; spec :PAnsiChar) :Integer; cdecl;

  //int git_object_lookup(git_object **object, git_repository *repo, const git_oid *id, git_otype type);
  git_object_lookup :function(var obj_out :PGitObject; repo: PGitRepository; id :PGitOid; objtype :git_otype) :Integer; cdecl;

  // git_otype git_object_type(const git_object *obj);
  git_object_type :function(obj :PGitObject) :git_otype; cdecl;

  //const git_oid * git_object_id(const git_object *obj);
  git_object_id :function(obj :PGitObject) :PGitOid; cdecl;

  //int git_object_short_id(git_buf *out, const git_object *obj);
  git_object_short_id :function(var buf :TGitBuf; obj :PGitObject) :Integer; cdecl;

  //void git_object_free(git_object *object);
  git_object_free :procedure(obj :PGitObject); cdecl;

  // GIT_EXTERN(size_t) git_blob_rawsize(git_blob *blob);
  git_blob_rawsize :function(blob :PGitBlob) :size_t; cdecl;

  // GIT_EXTERN(const void *) git_blob_rawcontent(git_blob *blob);
  git_blob_rawcontent :function(blob :PGitBlob) :PByte; cdecl;

  //int git_blob_filtered_content(git_buf *out, git_blob *blob, const char *as_path, int check_for_binary_data);
  git_blob_filtered_content :function(var buf :TGitBuf; blob :PGitBlob; AsPath :PAnsiChar; check_for_binary_data :Integer) :Integer; cdecl;

  // int git_revwalk_new(git_revwalk **out, git_repository *repo);
  git_revwalk_new :function(var walker :PGitRevwalk; repo :PGitRepository) :Integer; cdecl;

  // int git_revwalk_push_head(git_revwalk *walk);
  git_revwalk_push_head :function(walk :PGitRevwalk) :Integer; cdecl;

  // int git_revwalk_next(git_oid *out, git_revwalk *walk);
  git_revwalk_next :function(oid :PGitOid; walk :PGitRevwalk) :Integer; cdecl;

  // void git_revwalk_free(git_revwalk *walk);
  git_revwalk_free :procedure(walk :PGitRevwalk); cdecl;

  //---------------------------------------------------------------------------
  // Commit

  //int git_commit_create(git_oid *id, git_repository *repo, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, const git_commit *[] parents);
  git_commit_create :function(
    var oid :TGitOID;
    repo :PGitRepository;
    update_ref :PAnsiChar;
    author :PGitSignature;
    committer :PGitSignature;
    message_encoding :PAnsiChar;
    message_text :PAnsiChar;
    tree :PGitTree;
    parent_count :size_t;
    parents :PGitCommitArray) :Integer; cdecl;

  //int git_commit_amend(git_oid *id, const git_commit *commit_to_amend, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree);
  git_commit_amend :function(
    var oid :TGitOID;
    commit_to_amend :PGitCommit;
    update_ref :PAnsiChar;
    author :PGitSignature;
    committer :PGitSignature;
    message_encoding :PAnsiChar;
    message_text :PAnsiChar;
    tree :PGitTree) :Integer; cdecl;


  // int git_commit_lookup(git_commit **commit, git_repository *repo, const git_oid *id);
  git_commit_lookup :function(var commit :PGitCommit; repo :PGitRepository; oid :PGitOid) :Integer; cdecl;

  // void git_commit_free(git_commit *commit);
  git_commit_free :procedure(commit :PGitCommit); cdecl;

  //const git_oid * git_commit_id(const git_commit *commit);
  git_commit_id :function (commit :PGitCommit) :PGitOid; cdecl;

  // unsigned int git_commit_parentcount(const git_commit *commit);
  git_commit_parentcount :function (commit :PGitCommit) :UInt; cdecl;

  // int git_commit_parent(git_commit **out, const git_commit *commit, unsigned int n);
  git_commit_parent :function (var parent :PGitCommit; commit :PGitCommit; n :UInt) :Integer; cdecl;

  // const git_signature * git_commit_author(const git_commit *commit);
  git_commit_author :function(commit :PGitCommit) :PGitSignature; cdecl;

  // const char * git_commit_message(const git_commit *commit);
  git_commit_message :function(commit :PGitCommit) :PAnsiChar; cdecl;

  // int git_commit_tree(git_tree **tree_out, const git_commit *commit);
  git_commit_tree :function (var tree_out :PGitTree; commit :PGitCommit) :Integer; cdecl;

  // int git_annotated_commit_from_ref(git_annotated_commit **out, git_repository *repo, const git_reference *ref);
  git_annotated_commit_from_ref :function(var commit :PGitAnnotCommit; repo :PGitRepository; ref :PGitReference) :Integer; cdecl;

  //void git_annotated_commit_free(git_annotated_commit *commit);
  git_annotated_commit_free :procedure(commit :PGitAnnotCommit); cdecl;


  //---------------------------------------------------------------------------
  // Tree

  //int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id);
  git_tree_lookup :function(var tree :PGitTree; repo :PGitRepository; oid :PGitOid) :Integer; cdecl;

  // void git_tree_free(git_tree *tree);
  git_tree_free :procedure(tree :PGitTree); cdecl;


  //---------------------------------------------------------------------------
  // Diff

  // int git_diff_tree_to_tree(git_diff **diff, git_repository *repo, git_tree *old_tree, git_tree *new_tree, const git_diff_options *opts);
  git_diff_tree_to_tree :function(var diff :PGitDiff; repo :PGitRepository; old_tree :PGitTree; new_tree :PGitTree; opts :PGitDiffOptions) :Integer; cdecl;

  //int git_diff_tree_to_workdir(git_diff **diff, git_repository *repo, git_tree *old_tree, const git_diff_options *opts);
  git_diff_tree_to_workdir :function(var diff :PGitDiff; repo :PGitRepository; old_tree :PGitTree; opts :PGitDiffOptions) :Integer; cdecl;

  // size_t git_diff_num_deltas(const git_diff *diff);
  git_diff_num_deltas :function(diff :PGitDiff) :size_t; cdecl;

  // int git_diff_print(git_diff *diff, git_diff_format_t format, git_diff_line_cb print_cb, void *payload);
  git_diff_print :function(
    diff :PGitDiff;
    format :uint{git_diff_format_t};
    print_cb :git_diff_line_cb;
    payload :pointer)
      :Integer; cdecl;

  // int git_diff_foreach(git_diff *diff, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload);
  git_diff_foreach :function(
    diff :PGitDiff;
    file_cb :git_diff_file_cb;
    binary_cb :pointer{git_diff_binary_cb};
    hunk_cb :pointer{git_diff_hunk_cb};
    line_cb :git_diff_line_cb;
    payload :pointer)
      :Integer; cdecl;

  // void git_diff_free(git_diff *diff);
  git_diff_free :procedure(diff :PGitDiff); cdecl;


  //---------------------------------------------------------------------------
  // Branch

  // int git_branch_iterator_new(git_branch_iterator **out, git_repository *repo, git_branch_t list_flags);
  git_branch_iterator_new :function(var iterator :PGitBranchIterator; repo :PGitRepository; list_flags :uint{git_branch_t}) :Integer; cdecl;

  // int git_branch_next(git_reference **out, git_branch_t *out_type, git_branch_iterator *iter);
  git_branch_next :function(var branch_ref :PGitReference; var out_type :uint{git_branch_t}; iter :PGitBranchIterator) :Integer; cdecl;

  // void git_branch_iterator_free(git_branch_iterator *iter);
  git_branch_iterator_free :procedure(iter :PGitBranchIterator); cdecl;

  //int git_branch_name(const char **out, const git_reference *ref);
  git_branch_name :function(var out_name :PAnsiChar; branch_ref :PGitReference) :Integer; cdecl;

  // int git_branch_is_head(const git_reference *branch);
  git_branch_is_head :function(branch_ref :PGitReference) :integer; cdecl;

  //int git_branch_create(git_reference **out, git_repository *repo, const char *branch_name, const git_commit *target, int force);
  git_branch_create :function(var branch_ref :PGitReference; repo :PGitRepository; branch_name :PAnsiChar; target :PGitCommit; force :Integer) :Integer; cdecl;

  //int git_branch_move(git_reference **out, git_reference *branch, const char *new_branch_name, int force);
  git_branch_move :function(var branch_ref :PGitReference; branch :PGitReference; new_branch_name :PAnsiChar; force :Integer) :Integer; cdecl;

  //int git_branch_delete(git_reference *branch);
  git_branch_delete :function(branch :PGitReference) :Integer; cdecl;


  //---------------------------------------------------------------------------
  // Tag

  //int git_tag_foreach(git_repository *repo, git_tag_foreach_cb callback, void *payload)
  git_tag_foreach :function(repo :PGitRepository; callback :git_tag_foreach_cb; payload :pointer) :Integer; cdecl;


  //---------------------------------------------------------------------------
  // Checkout

  //int git_checkout_tree(git_repository *repo, const git_object *treeish, const git_checkout_options *opts);
  git_checkout_tree :function(repo :PGitRepository; treeish :PGitObject; opts :PGitCheckoutOptions ) :Integer; cdecl;


  //---------------------------------------------------------------------------
  // Index

  //int git_repository_index(git_index **out, git_repository *repo);
  git_repository_index :function(var index :PGitIndex; repo :PGitRepository) :integer; cdecl;

  //size_t git_index_entrycount(const git_index *index);
  git_index_entrycount :function(index :PGitIndex) :size_t; cdecl;

  //int git_index_add_bypath(git_index *index, const char *path);
  git_index_add_bypath :function(index :PGitIndex; path :PAnsiChar) :Integer; cdecl;

  // int git_index_add_all(git_index *index, const git_strarray *pathspec, unsigned int flags, git_index_matched_path_cb callback, void *payload);
  git_index_add_all :function(index :PGitIndex; pathspec :pgit_strarray; flags :uint; callback :pointer{git_index_matched_path_cb}; payload :pointer) :Integer; cdecl;

  //int git_index_remove_bypath(git_index *index, const char *path);
  git_index_remove_bypath :function(index :PGitIndex; path :PAnsiChar) :Integer; cdecl;

  //int git_index_remove(git_index *index, const char *path, int stage);
  git_index_remove :function(index :PGitIndex; path :PAnsiChar; Stage :Integer) :Integer; cdecl;

  //int git_index_clear(git_index *index);
  git_index_clear :function(index :PGitIndex) :integer; cdecl;

  //int git_index_write(git_index *index);
  git_index_write :function(index :PGitIndex) :integer; cdecl;

  //int git_index_write_tree(git_oid *out, git_index *index);
  git_index_write_tree :function(var oid :TGitOID; index :PGitIndex) :integer; cdecl;

  //void git_index_free(git_index *index);
  git_index_free :procedure(index :PGitIndex); cdecl;

  // int git_reset_default(git_repository *repo, const git_object *target, const git_strarray *pathspecs);
  git_reset_default :function(repo :PGitRepository; target :PGitObject; pathspec :pgit_strarray) :integer; cdecl;


  //---------------------------------------------------------------------------
  // Signature

  //int git_signature_default(git_signature **out, git_repository *repo);
  git_signature_default :function(var sig :PGitSignature; repo: PGitRepository) :integer; cdecl;

  //int git_signature_now(git_signature **out, const char *name, const char *email);
  git_signature_now :function(var sig :PGitSignature; name, email :PAnsiChar) :integer; cdecl;

  //void git_signature_free(git_signature *sig);
  git_signature_free :procedure(sig :PGitSignature); cdecl;


  //---------------------------------------------------------------------------
  // Remote

  // int git_remote_list(git_strarray *out, git_repository *repo);
  git_remote_list :function(var out_list :TGitStrArray; repo: PGitRepository) :Integer; cdecl;

  //int git_remote_lookup(git_remote **out, git_repository *repo, const char *name);
  git_remote_lookup :function(var remote :PGitRemote; repo: PGitRepository; name :PAnsiChar) :Integer; cdecl;

  //const char * git_remote_url(const git_remote *remote);
  git_remote_url :function(remote :PGitRemote) :PAnsiChar; cdecl;

  //void git_remote_free(git_remote *remote);
  git_remote_free :procedure(remote :PGitRemote); cdecl;


  //---------------------------------------------------------------------------
  // Pathspec

  // int git_pathspec_new(git_pathspec **out, const git_strarray *pathspec);
  git_pathspec_new :function(var out_ps :PGitPathspec; pathspec: PGitStrArray) :integer; cdecl;

  // int git_pathspec_match_tree(git_pathspec_match_list **out, git_tree *tree, uint32_t flags, git_pathspec *ps);
  git_pathspec_match_tree :function(pout :pointer; tree :PGitTree; flags :uint32_t; ps :PGitPathspec) :integer; cdecl;

  // void git_pathspec_free(git_pathspec *ps);
  git_pathspec_free :procedure(ps :PGitPathspec); cdecl;


  //void git_strarray_free(git_strarray *array);
  git_strarray_free :procedure(arr :PGitStrArray); cdecl;

  //void git_buf_free(git_buf *buffer);
  git_buf_free :procedure(buf :PGitBuf); cdecl;

  //char * git_oid_tostr(char *out, size_t n, const git_oid *id);
  git_oid_tostr :function(buf :PAnsiChar; size :size_t; id :PGitOid) :PAnsiChar; cdecl;


//   /// attr.h
//   ///   Attribute management
//
////   GIT_EXTERN(const char *)git_attr__true;
//   git_attr__true:                     function (): PAnsiChar; stdcall;
////   GIT_EXTERN(const char *)git_attr__false;
//   git_attr__false:                    function (): PAnsiChar; stdcall;
//
////   GIT_EXTERN(int) git_attr_get(git_repository *repo, const char *path, const char *name, const char **value);
//   git_attr_get:                       function (repo: PGitRepository; path, name: PAnsiChar; var value: PAnsiChar): Integer; stdcall;
////   GIT_EXTERN(int) git_attr_get_many(git_repository *repo, const char *path, size_t num_attr, const char **names, const char **values);
//   git_attr_get_many:                  function (repo: PGitRepository; path: PAnsiChar; num_attr: size_t; names: PPAnsiChar; var values: PAnsiChar): Integer; stdcall;
////   GIT_EXTERN(int) git_attr_foreach(git_repository *repo, const char *path, int (*callback)(const char *name, const char *value, void *payload), void *payload);
//   git_attr_foreach:                   function (repo: PGitRepository; path: PAnsiChar; callback: Pgit_attr_foreach_callback; payload: PByte): Integer; stdcall;
////   GIT_EXTERN(void) git_attr_cache_flush(git_repository *repo);
//   git_attr_cache_flush:               procedure (repo: PGitRepository); stdcall;
////   GIT_EXTERN(int) git_attr_add_macro(git_repository *repo, const char *name, const char *values);
//   git_attr_add_macro:                 function (repo: PGitRepository; name, values: PAnsiChar): Integer; stdcall;
//
//   /// blob.h
//   ///
//
//   // GIT_EXTERN(int) git_blob_create_fromfile(git_oid *oid, git_repository *repo, const char *path);
//   git_blob_create_fromfile:           function (oid: Pgit_oid; repo: PGitRepository; const path: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_blob_create_frombuffer(git_oid *oid, git_repository *repo, const void *buffer, size_t len);
//   git_blob_create_frombuffer:         function (oid: Pgit_oid; repo: PGitRepository; const buffer: PByte; len: size_t): Integer; stdcall;
//
//   /// commit.h
//   ///
//
////   GIT_EXTERN(const char *) git_commit_message_encoding(git_commit *commit);
//   git_commit_message_encoding:        function (commit: Pgit_commit): PAnsiChar; stdcall;
//   // GIT_EXTERN(git_time_t) git_commit_time(git_commit *commit);
//   git_commit_time:                    function (commit: Pgit_commit): git_time_t; stdcall;
//   // GIT_EXTERN(int) git_commit_time_offset(git_commit *commit);
//   git_commit_time_offset:             function (commit: Pgit_commit): Integer; stdcall;
//   // GIT_EXTERN(const git_signature *) git_commit_committer(git_commit *commit);
//   git_commit_committer:               function (commit: Pgit_commit): Pgit_signature; stdcall;
//   // GIT_EXTERN(const git_oid *) git_commit_tree_oid(git_commit *commit);
//   git_commit_tree_oid:                function (commit: Pgit_commit): Pgit_oid; stdcall;
//   // GIT_EXTERN(const git_oid *) git_commit_parent_oid(git_commit *commit, unsigned int n);
//   git_commit_parent_oid:              function (commit: Pgit_commit; n: UInt): Pgit_oid; stdcall;
//
//   /// common.h
//   ///
//
//   // GIT_EXTERN(void) git_libgit2_version(int *major, int *minor, int *rev);
//   git_libgit2_version:                procedure (out major, minor, rev: Integer); stdcall;
//
//   /// config.h
//   ///
//
//   // GIT_EXTERN(int) git_config_find_global(char *global_config_path);
//   git_config_find_global:             function (global_config_path: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_find_system(char *system_config_path);
//   git_config_find_system:             function (system_config_path: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_open_global(git_config **out);
//   git_config_open_global:             function (var out_: Pgit_config): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_file__ondisk(struct git_config_file **out, const char *path);
//   git_config_file__ondisk:            function (var out_: Pgit_config_file; const path: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_new(git_config **out);
//   git_config_new:                     function (var out_: Pgit_config): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_add_file(git_config *cfg, git_config_file *file, int priority);
//   git_config_add_file:                function (cfg: Pgit_config; file_: Pgit_config_file; priority: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_add_file_ondisk(git_config *cfg, const char *path, int priority);
//   git_config_add_file_ondisk:         function (cfg: Pgit_config; const path: PAnsiChar; priority: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_open_ondisk(git_config **cfg, const char *path);
//   git_config_open_ondisk:             function (out cfg: Pgit_config; const path: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(void) git_config_free(git_config *cfg);
//   git_config_free:                    procedure (cfg: Pgit_config); stdcall;
//   // GIT_EXTERN(int) git_config_get_int32(git_config *cfg, const char *name, int32_t *out);
//   git_config_get_int32:               function (cfg: Pgit_config; name: PAnsiChar; out_: PInt32_t): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_get_int64(git_config *cfg, const char *name, int64_t *out);
//   git_config_get_int64:               function (cfg: Pgit_config; name: PAnsiChar; out_: PInt64_t): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_get_bool(git_config *cfg, const char *name, int *out);
//   git_config_get_bool:                function (cfg: Pgit_config; const name: PAnsiChar; var out_: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_get_string(git_config *cfg, const char *name, const char **out);
//   git_config_get_string:              function (cfg: Pgit_config; const name: PAnsiChar; var out_: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_set_int32(git_config *cfg, const char *name, int32_t value);
//   git_config_set_int32:               function (cfg: Pgit_config; name: PAnsiChar; value: Int32): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_set_int64(git_config *cfg, const char *name, int64_t value);
//   git_config_set_int64:               function (cfg: Pgit_config; name: PAnsiChar; value: Int64): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_set_bool(git_config *cfg, const char *name, int value);
//   git_config_set_bool:                function (cfg: Pgit_config; const name: PAnsiChar; value: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_set_string(git_config *cfg, const char *name, const char *value);
//   git_config_set_string:              function (cfg: Pgit_config; const name: PAnsiChar; const value: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_delete(git_config *cfg, const char *name);
//   git_config_delete:                  function (cfg: Pgit_config; name: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_config_foreach(git_config *cfg, int (*callback)(const char *var_name, const char *value, void *payload), void *payload);
//   git_config_foreach:                 function (cfg: Pgit_config; callback: Pgit_config_foreach_callback; payload: PByte): Integer; stdcall;
//
//   /// errors.h
//   ///
//
//   // GIT_EXTERN(const char *) git_lasterror(void);
//   git_lasterror:                      function: PAnsiChar; stdcall;
//   // GIT_EXTERN(const char *) git_strerror(int num);
//   git_strerror:                       function (num: Integer): PAnsiChar; stdcall;
//   // GIT_EXTERN(void) git_clearerror(void);
//   git_clearerror:                     procedure; stdcall;
//
//   /// index.h
//   ///
//
//   // GIT_EXTERN(int) git_index_open(git_index **index, const char *index_path);
//   git_index_open:                     function (var index: Pgit_index; const index_path: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_index_read(git_index *index);
//   git_index_read:                     function (index: Pgit_index): Integer; stdcall;
//   // GIT_EXTERN(int) git_index_find(git_index *index, const char *path);
//   git_index_find:                     function (index: Pgit_index; const path: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(void) git_index_uniq(git_index *index);
//   git_index_uniq:                     procedure (index: Pgit_index); stdcall;
//   // GIT_EXTERN(int) git_index_add(git_index *index, const char *path, int stage);
//   git_index_add:                      function (index: Pgit_index; const path: PAnsiChar; stage: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_index_add2(git_index *index, const git_index_entry *source_entry);
//   git_index_add2:                     function (index: Pgit_index; const source_entry: Pgit_index_entry): Integer; stdcall;
//   // GIT_EXTERN(int) git_index_append(git_index *index, const char *path, int stage);
//   git_index_append:                   function (index: Pgit_index; const path: PAnsiChar; stage: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_index_append2(git_index *index, const git_index_entry *source_entry);
//   git_index_append2:                  function (index: Pgit_index; const source_entry: Pgit_index_entry): Integer; stdcall;
//   // GIT_EXTERN(git_index_entry *) git_index_get(git_index *index, unsigned int n);
//   git_index_get:                      function (index: Pgit_index; n: UInt): Pgit_index_entry; stdcall;
//   // GIT_EXTERN(unsigned int) git_index_entrycount(git_index *index);
//   git_index_entrycount:               function (index: Pgit_index): UInt; stdcall;
//   // GIT_EXTERN(unsigned int) git_index_entrycount_unmerged(git_index *index);
//   git_index_entrycount_unmerged:      function (index: Pgit_index): UInt; stdcall;
//   // GIT_EXTERN(const git_index_entry_unmerged *) git_index_get_unmerged_bypath(git_index *index, const char *path);
//   git_index_get_unmerged_bypath:      function (index: Pgit_index; const path: PAnsiChar): Pgit_index_entry_unmerged; stdcall;
//   // GIT_EXTERN(const git_index_entry_unmerged *) git_index_get_unmerged_byindex(git_index *index, unsigned int n);
//   git_index_get_unmerged_byindex:     function (index: Pgit_index; n: UInt): Pgit_index_entry_unmerged; stdcall;
//   // GIT_EXTERN(int) git_index_entry_stage(const git_index_entry *entry);
//   git_index_entry_stage:              function (const entry: Pgit_index_entry): Integer; stdcall;
//   // GIT_EXTERN(int) git_index_read_tree(git_index *index, git_tree *tree);
//   git_index_read_tree:                function (index: Pgit_index; tree: Pgit_tree): Integer; stdcall;
//
//   /// indexer.h
//   ///
//
//   // GIT_EXTERN(int) git_indexer_new(git_indexer **out, const char *packname);
//   git_indexer_new:                    function (var out_: Pgit_indexer; packname: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_indexer_run(git_indexer *idx, git_indexer_stats *stats);
//   git_indexer_run:                    function (idx: Pgit_indexer; stats: Pgit_indexer_stats): Integer; stdcall;
//   // GIT_EXTERN(int) git_indexer_write(git_indexer *idx);
//   git_indexer_write:                  function (idx: Pgit_indexer): Integer; stdcall;
//   // GIT_EXTERN(const git_oid *) git_indexer_hash(git_indexer *idx);
//   git_indexer_hash:                   function (idx: Pgit_indexer): Pgit_oid; stdcall;
//   // GIT_EXTERN(void) git_indexer_free(git_indexer *idx);
//   git_indexer_free:                   procedure (idx: Pgit_indexer); stdcall;
//
//   /// object.h
//   ///
//
//   // GIT_EXTERN(int) git_object_lookup_prefix(git_object **object_out, git_repository *repo, const git_oid *id, unsigned int len, git_otype type);
//   git_object_lookup_prefix:           function (var object_out: Pgit_object; repo: PGitRepository; const id: Pgit_oid; len: UInt; type_: git_otype): Integer; stdcall;
//   // GIT_EXTERN(git_repository *) git_object_owner(const git_object *obj);
//   git_object_owner:                   function (obj: Pgit_object): PGitRepository; stdcall;
//   // GIT_EXTERN(const char *) git_object_type2string(git_otype type);
//   git_object_type2string:             function (type_: git_otype): PAnsiChar; stdcall;
//   // GIT_EXTERN(git_otype) git_object_string2type(const char *str);
//   git_object_string2type:             function (const str: PAnsiChar): git_otype; stdcall;
//   // GIT_EXTERN(int) git_object_typeisloose(git_otype type);
//   git_object_typeisloose:             function (type_: git_otype): Integer; stdcall;
//   // GIT_EXTERN(size_t) git_object__size(git_otype type);
//   git_object__size:                   function (type_: git_otype): size_t; stdcall;
//
//   /// odb.h
//   ///
//
//   // GIT_EXTERN(int) git_odb_new(git_odb **out);
//   git_odb_new:                        function (var out_: Pgit_odb): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_open(git_odb **out, const char *objects_dir);
//   git_odb_open:                       function (var out_: Pgit_odb; const objects_dir: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_add_backend(git_odb *odb, git_odb_backend *backend, int priority);
//   git_odb_add_backend:                function (odb: Pgit_odb; backend: Pgit_odb_backend; priority: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_add_alternate(git_odb *odb, git_odb_backend *backend, int priority);
//   git_odb_add_alternate:              function (odb: Pgit_odb; backend: Pgit_odb_backend; priority: Integer): Integer; stdcall;
//   // GIT_EXTERN(void) git_odb_free(git_odb *db);
//   git_odb_free:                       procedure (db: Pgit_odb); stdcall;
//   // GIT_EXTERN(int) git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id);
//   git_odb_read:                       function (var out_: Pgit_odb_object; db: Pgit_odb; const id: Pgit_oid): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_read_prefix(git_odb_object **out, git_odb *db, const git_oid *short_id, unsigned int len);
//   git_odb_read_prefix:                function (var out_: Pgit_odb_object; db: Pgit_odb; const short_id: Pgit_oid; len: UInt): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_read_header(size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id);
//   git_odb_read_header:                function (var len_p: size_t; var type_p: git_otype; db: Pgit_odb; const id: Pgit_oid): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_exists(git_odb *db, const git_oid *id);
//   git_odb_exists:                     function (db: Pgit_odb; const id: Pgit_oid): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_write(git_oid *oid, git_odb *odb, const void *data, size_t len, git_otype type);
//   git_odb_write:                      function (oid: Pgit_oid; odb: Pgit_odb; const data: PByte; len: size_t; type_: git_otype): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_open_wstream(git_odb_stream **stream, git_odb *db, size_t size, git_otype type);
//   git_odb_open_wstream:               function (var stream: Pgit_odb_stream; db: Pgit_odb; size: size_t; type_: git_otype): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_open_rstream(git_odb_stream **stream, git_odb *db, const git_oid *oid);
//   git_odb_open_rstream:               function (var stream: Pgit_odb_stream; db: Pgit_odb; const oid: Pgit_oid): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_hash(git_oid *id, const void *data, size_t len, git_otype type);
//   git_odb_hash:                       function (id: Pgit_oid; const data: PByte; len: size_t; type_: git_otype): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_hashfile(git_oid *out, const char *path, git_otype type);
//   git_odb_hashfile:                   function (out_: Pgit_oid; path: PAnsiChar; type_: git_otype): Integer; stdcall;
//   // GIT_EXTERN(void) git_odb_object_free(git_odb_object *object);
//   git_odb_object_free:                procedure (object_: Pgit_odb_object); stdcall;
//   // GIT_EXTERN(const git_oid *) git_odb_object_id(git_odb_object *object);
//   git_odb_object_id:                  function (object_: Pgit_odb_object): Pgit_oid; stdcall;
//   // GIT_EXTERN(const void *) git_odb_object_data(git_odb_object *object);
//   git_odb_object_data:                function (object_: Pgit_odb_object): PByte; stdcall;
//   // GIT_EXTERN(size_t) git_odb_object_size(git_odb_object *object);
//   git_odb_object_size:                function (object_: Pgit_odb_object): size_t; stdcall;
//   // GIT_EXTERN(git_otype) git_odb_object_type(git_odb_object *object);
//   git_odb_object_type:                function (object_: Pgit_odb_object): git_otype; stdcall;
//
//   /// odb_backend.h
//   ///
//
//   // GIT_EXTERN(int) git_odb_backend_pack(git_odb_backend **backend_out, const char *objects_dir);
//   git_odb_backend_pack:               function (var backend_out: Pgit_odb_backend; const objects_dir: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_odb_backend_loose(git_odb_backend **backend_out, const char *objects_dir, int compression_level, int do_fsync);
//   git_odb_backend_loose:              function (var backend_out: Pgit_odb_backend; const objects_dir: PAnsiChar; compression_leve: Integer; do_fsync: Integer): Integer; stdcall;
//
//   /// oid.h
//   ///
//
//   // GIT_EXTERN(int) git_oid_fromstr(git_oid *out, const char *str);
//   git_oid_fromstr:                    function (aOut: Pgit_oid; aStr: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_oid_fromstrn(git_oid *out, const char *str, size_t length);
//   git_oid_fromstrn:                   function (out_: Pgit_oid; str: PAnsiChar; length: size_t): Integer; stdcall;
//   // GIT_EXTERN(void) git_oid_fromraw(git_oid *out, const unsigned char *raw);
//   git_oid_fromraw:                    procedure (out_: Pgit_oid; const raw: PByte); stdcall;
//   // GIT_EXTERN(void) git_oid_fmt(char *str, const git_oid *oid);
//   git_oid_fmt:                        procedure (aStr: PAnsiChar; const oid: Pgit_oid); stdcall;
//   // GIT_EXTERN(void) git_oid_pathfmt(char *str, const git_oid *oid);
//   git_oid_pathfmt:                    procedure (aStr: PAnsiChar; const oid: Pgit_oid); stdcall;
//   // GIT_EXTERN(char *) git_oid_allocfmt(const git_oid *oid);
//   git_oid_allocfmt:                   function (const oid: Pgit_oid): PAnsiChar; stdcall;
//   // GIT_EXTERN(char *) git_oid_to_string(char *out, size_t n, const git_oid *oid);
//   git_oid_to_string:                  function (out_: PAnsiChar; n: size_t; const oid: Pgit_oid): PAnsiChar; stdcall;
//   // GIT_EXTERN(void) git_oid_cpy(git_oid *out, const git_oid *src);
//   git_oid_cpy:                        procedure (out_: Pgit_oid; const src: Pgit_oid); stdcall;
//   // GIT_EXTERN(int) git_oid_cmp(const git_oid *a, const git_oid *b);
//   git_oid_cmp:                        function (const a, b: Pgit_oid): Integer; stdcall;
//   // GIT_EXTERN(int) git_oid_ncmp(const git_oid *a, const git_oid *b, unsigned int len);
//   git_oid_ncmp:                       function (const a, b: Pgit_oid; len: UInt): Integer; stdcall;
//   // GIT_EXTERN(int) git_oid_streq(const git_oid *a, const char *str);
//   git_oid_streq:                      function (a: Pgit_oid; str: PAnsiChar): Integer; stdcall;
//
//   /// reflog.h
//   ///
//
//   // GIT_EXTERN(int) git_reflog_read(git_reflog **reflog, git_reference *ref);
//   git_reflog_read:                    function (var reflog: Pgit_reflog; ref: Pgit_reference): Integer; stdcall;
//   // GIT_EXTERN(int) git_reflog_write(git_reference *ref, const git_oid *oid_old, const git_signature *committer, const char *msg);
//   git_reflog_write:                   function (ref: Pgit_reference; oid_old: Pgit_oid; committer: Pgit_signature; msg: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_reflog_rename(git_reference *ref, const char *new_name);
//   git_reflog_rename:                  function (ref: Pgit_reference; new_name: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_reflog_delete(git_reference *ref);
//   git_reflog_delete:                  function (ref: Pgit_reference): Integer; stdcall;
//   // GIT_EXTERN(unsigned int) git_reflog_entrycount(git_reflog *reflog);
//   git_reflog_entrycount:              function (reflog: Pgit_reflog): UInt; stdcall;
//   // GIT_EXTERN(const git_reflog_entry *) git_reflog_entry_byindex(git_reflog *reflog, unsigned int idx);
//   git_reflog_entry_byindex:           function (reflog: Pgit_reflog; idx: UInt): Pgit_reflog_entry; stdcall;
//   // GIT_EXTERN(const git_oid *) git_reflog_entry_oidold(const git_reflog_entry *entry);
//   git_reflog_entry_oidold:            function (entry: Pgit_reflog_entry): Pgit_oid; stdcall;
//   // GIT_EXTERN(const git_oid *) git_reflog_entry_oidnew(const git_reflog_entry *entry);
//   git_reflog_entry_oidnew:            function (entry: Pgit_reflog_entry): Pgit_oid; stdcall;
//   // GIT_EXTERN(git_signature *) git_reflog_entry_committer(const git_reflog_entry *entry);
//   git_reflog_entry_committer:         function (entry: Pgit_reflog_entry): Pgit_signature; stdcall;
//   // GIT_EXTERN(char *) git_reflog_entry_msg(const git_reflog_entry *entry);
//   git_reflog_entry_msg:               function (entry: Pgit_reflog_entry): PAnsiChar; stdcall;
//   // GIT_EXTERN(void) git_reflog_free(git_reflog *reflog);
//   git_reflog_free:                    procedure (reflog: Pgit_reflog); stdcall;
//
//   /// refs.h
//   ///
//
//   // GIT_EXTERN(int) git_reference_create_symbolic(git_reference **ref_out, git_repository *repo, const char *name, const char *target, int force);
//   git_reference_create_symbolic:      function (var ref_out: Pgit_reference; repo: PGitRepository; const name: PAnsiChar; const target: PAnsiChar; force: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_reference_create_oid(git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id, int force);
//   git_reference_create_oid:           function (var ref_out: Pgit_reference; repo: PGitRepository; const name: PAnsiChar; const id: Pgit_oid; force: Integer): Integer; stdcall;
//   // GIT_EXTERN(const git_oid *) git_reference_oid(git_reference *ref);
//   git_reference_oid:                  function (ref: Pgit_reference): Pgit_oid; stdcall;
//   // GIT_EXTERN(const char *) git_reference_target(git_reference *ref);
//   git_reference_target:               function (ref: Pgit_reference): PAnsiChar; stdcall;
//   // GIT_EXTERN(git_rtype) git_reference_type(git_reference *ref);
//   git_reference_type:                 function (ref: Pgit_reference): git_rtype; stdcall;
//   // GIT_EXTERN(int) git_reference_resolve(git_reference **resolved_ref, git_reference *ref);
//   git_reference_resolve:              function (var resolved_ref: Pgit_reference; ref: Pgit_reference): Integer; stdcall;
//   // GIT_EXTERN(git_repository *) git_reference_owner(git_reference *ref);
//   git_reference_owner:                function (ref: Pgit_reference): PGitRepository; stdcall;
//   // GIT_EXTERN(int) git_reference_set_target(git_reference *ref, const char *target);
//   git_reference_set_target:           function (ref: Pgit_reference; const target: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_reference_set_oid(git_reference *ref, const git_oid *id);
//   git_reference_set_oid:              function (ref: Pgit_reference; const id: Pgit_oid): Integer; stdcall;
//   // GIT_EXTERN(int) git_reference_rename(git_reference *ref, const char *new_name, int force);
//   git_reference_rename:               function (ref: Pgit_reference; const new_name: PAnsiChar; force: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_reference_delete(git_reference *ref);
//   git_reference_delete:               function (ref: Pgit_reference): Integer; stdcall;
//   // GIT_EXTERN(int) git_reference_packall(git_repository *repo);
//   git_reference_packall:              function (repo: PGitRepository): Integer; stdcall;
//   // GIT_EXTERN(int) git_reference_listall(git_strarray *array, git_repository *repo, unsigned int list_flags);
//   git_reference_listall:              function (array_: Pgit_strarray; repo: PGitRepository; list_flags: UInt): Integer; stdcall;
//   // GIT_EXTERN(int) git_reference_foreach(git_repository *repo, unsigned int list_flags, int (*callback)(const char *, void *), void *payload);
//   git_reference_foreach:              function (repo: PGitRepository; list_flags: UInt; callback: Pgit_reference_foreach_callback; payload: PByte): Integer; stdcall;
//   // GIT_EXTERN(int) git_reference_is_packed(git_reference *ref);
//   git_reference_is_packed:            function (ref: Pgit_reference): Integer; stdcall;
//   // GIT_EXTERN(int) git_reference_reload(git_reference *ref);
//   git_reference_reload:               function (ref: Pgit_reference): Integer; stdcall;
//
//   /// remote.h
//   ///
//
//   // GIT_EXTERN(int) git_remote_new(git_remote **out, git_repository *repo, const char *url, const char *name);
//   git_remote_new:                     function (var out_: Pgit_remote; repo: PGitRepository; url, name: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_remote_load(git_remote **out, git_repository *repo, const char *name);
//   git_remote_load:                    function (var out_: Pgit_remote; repo: PGitRepository; name: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(const char *) git_remote_name(git_remote *remote);
//   git_remote_name:                    function (remote: Pgit_remote): PAnsiChar; stdcall;
//   // GIT_EXTERN(const git_refspec *) git_remote_fetchspec(git_remote *remote);
//   git_remote_fetchspec:               function (remote: Pgit_remote): Pgit_refspec; stdcall;
//   // GIT_EXTERN(const git_refspec *) git_remote_pushspec(git_remote *remote);
//   git_remote_pushspec:                function (remote: Pgit_remote): Pgit_refspec; stdcall;
//   // GIT_EXTERN(int) git_remote_connect(git_remote *remote, int direction);
//   git_remote_connect:                 function (remote: Pgit_remote; direction: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_remote_ls(git_remote *remote, git_headlist_cb list_cb, void *payload);
//   git_remote_ls:                      function (remote: Pgit_remote; list_cb: git_headlist_cb; payload: PByte): Integer; stdcall;
//   // GIT_EXTERN(int) git_remote_download(char **filename, git_remote *remote);
//   git_remote_download:                function (var filename: PAnsiChar; remote: Pgit_remote): Integer; stdcall;
//   // GIT_EXTERN(int) git_remote_connected(git_remote *remote);
//   git_remote_connected:               function (remote: Pgit_remote): Integer; stdcall;
//   // GIT_EXTERN(void) git_remote_disconnect(git_remote *remote);
//   git_remote_disconnect:              procedure (remote: Pgit_remote); stdcall;
//   // GIT_EXTERN(int) git_remote_update_tips(git_remote *remote);
//   git_remote_update_tips:             function (remote: Pgit_remote): Integer; stdcall;
//   // GIT_EXTERN(int) git_remote_valid_url(const char *url);
//   git_remote_valid_url:               function (url: PAnsiChar): Integer; stdcall;
//
//   /// repository.h
//   ///
//
//
//
//   // GIT_EXTERN(int) git_repository_discover(char *repository_path, size_t size, const char *start_path, int across_fs, const char *ceiling_dirs);
//   git_repository_discover:            function (repository_path: PAnsiChar; size: size_t; const start_path: PAnsiChar; across_fs: Integer; const ceiling_dirs: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_repository_init(git_repository **repo_out, const char *path, unsigned is_bare);
//   git_repository_init:                function (var repo_out: PGitRepository; const path: PAnsiChar; is_bare: UInt): Integer; stdcall;
//   // GIT_EXTERN(int) git_repository_is_empty(git_repository *repo);
//   git_repository_is_empty:            function (repo: PGitRepository): Integer; stdcall;
//   // GIT_EXTERN(const char *) git_repository_path(git_repository *repo);
//   git_repository_path:                function (repo: PGitRepository): PAnsiChar; stdcall;
//   // GIT_EXTERN(int) git_repository_set_workdir(git_repository *repo, const char *workdir);
//   git_repository_set_workdir:         function (repo: PGitRepository; workdir: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_repository_is_bare(git_repository *repo);
//   git_repository_is_bare:             function (repo: PGitRepository): Integer; stdcall;
//   // GIT_EXTERN(int) git_repository_config(git_config **out, git_repository *repo);
//   git_repository_config:              function (var out_: Pgit_config; repo: PGitRepository): Integer; stdcall;
//   // GIT_EXTERN(void) git_repository_set_config(git_repository *repo, git_config *config);
//   git_repository_set_config:          procedure (repo: PGitRepository; config: Pgit_config); stdcall;
//   // GIT_EXTERN(int) git_repository_odb(git_odb **out, git_repository *repo);
//   git_repository_odb:                 function (var out_: Pgit_odb; repo: PGitRepository): Integer; stdcall;
//   // GIT_EXTERN(void) git_repository_set_odb(git_repository *repo, git_odb *odb);
//   git_repository_set_odb:             procedure (repo: PGitRepository; odb: Pgit_odb); stdcall;
//   // GIT_EXTERN(void) git_repository_set_index(git_repository *repo, git_index *index);
//   git_repository_set_index:           procedure (repo: PGitRepository; index: Pgit_index); stdcall;
//
//   /// revwalk.h
//   ///
//
//   // GIT_EXTERN(void) git_revwalk_reset(git_revwalk *walker);
//   git_revwalk_reset:                  procedure (walker: Pgit_revwalk); stdcall;
//   // GIT_EXTERN(int) git_revwalk_push(git_revwalk *walk, const git_oid *oid);
//   git_revwalk_push:                   function (walk: Pgit_revwalk; const oid: Pgit_oid): Integer; stdcall;
//   // GIT_EXTERN(int) git_revwalk_hide(git_revwalk *walk, const git_oid *oid);
//   git_revwalk_hide:                   function (walk: Pgit_revwalk; const oid: Pgit_oid): Integer; stdcall;
//   // GIT_EXTERN(void) git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode);
//   git_revwalk_sorting:                procedure (walk: Pgit_revwalk; sort_mode: UInt); stdcall;
//   // GIT_EXTERN(git_repository *) git_revwalk_repository(git_revwalk *walk);
//   git_revwalk_repository:             function (walk: Pgit_revwalk): PGitRepository; stdcall;
//
//   /// signature.h
//   ///
//
//   // GIT_EXTERN(int) git_signature_new(git_signature **sig_out, const char *name, const char *email, git_time_t time, int offset);
//   git_signature_new:                  function (var sig_out: Pgit_signature; const name, email: PAnsiChar; time: git_time_t; offset: Integer): Integer; stdcall;
//   // GIT_EXTERN(git_signature *) git_signature_dup(const git_signature *sig);
//   git_signature_dup:                  function (const sig: Pgit_signature): Pgit_signature; stdcall;
//   // GIT_EXTERN(void) git_signature_free(git_signature *sig);
//   git_signature_free:                 procedure (sig: Pgit_signature); stdcall;
//
//   /// status.h
//   ///
//
//   // GIT_EXTERN(int) git_status_file(unsigned int *status_flags, git_repository *repo, const char *path);
//   git_status_file:                    function (status_flags: PUint; repo: PGitRepository; path: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_status_should_ignore(git_repository *repo, const char *path, int *ignored);
//   git_status_should_ignore:           function (repo: PGitRepository; path: PAnsiChar; ignored: PInt): Integer; stdcall;
//
//   /// tag.h
//   ///
//
//   // GIT_EXTERN(const git_oid *) git_tag_id(git_tag *tag);
//   git_tag_id:                         function (tag: Pgit_tag): Pgit_oid; stdcall;
//   // GIT_EXTERN(int) git_tag_target(git_object **target, git_tag *tag);
//   git_tag_target:                     function (var target: Pgit_object; tag: Pgit_tag): Integer; stdcall;
//   // GIT_EXTERN(const git_oid *) git_tag_target_oid(git_tag *tag);
//   git_tag_target_oid:                 function (tag: Pgit_tag): Pgit_oid; stdcall;
//   // GIT_EXTERN(git_otype) git_tag_type(git_tag *tag);
//   git_tag_type:                       function (tag: Pgit_tag): git_otype; stdcall;
//   // GIT_EXTERN(const char *) git_tag_name(git_tag *tag);
//   git_tag_name:                       function (tag: Pgit_tag): PAnsiChar; stdcall;
//   // GIT_EXTERN(const git_signature *) git_tag_tagger(git_tag *tag);
//   git_tag_tagger:                     function (tag: Pgit_tag): Pgit_signature; stdcall;
//   // GIT_EXTERN(const char *) git_tag_message(git_tag *tag);
//   git_tag_message:                    function (tag: Pgit_tag): PAnsiChar; stdcall;
//   // GIT_EXTERN(int) git_tag_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message, int force);
//   git_tag_create:                     function (oid: Pgit_oid; repo: PGitRepository; const tag_name: PAnsiChar; const target: Pgit_object; const tagger: Pgit_signature; const message_: PAnsiChar; force: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_tag_create_frombuffer(git_oid *oid, git_repository *repo, const char *buffer, int force);
//   git_tag_create_frombuffer:          function (oid: Pgit_oid; repo: PGitRepository; const buffer: PAnsiChar; force: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_tag_create_lightweight(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, int force);
//   git_tag_create_lightweight:         function (oid: Pgit_oid; repo: PGitRepository; tag_name: PAnsiChar; target: Pgit_object; force: Integer): Integer; stdcall;
//   // GIT_EXTERN(int) git_tag_delete(git_repository *repo, const char *tag_name);
//   git_tag_delete:                     function (repo: PGitRepository; const tag_name: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_tag_list(git_strarray *tag_names, git_repository *repo);
//   git_tag_list:                       function (tag_names: Pgit_strarray; repo: PGitRepository): Integer; stdcall;
//   // GIT_EXTERN(int) git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo);
//   git_tag_list_match:                 function (tag_names: Pgit_strarray; pattern: PAnsiChar; repo: PGitRepository): Integer; stdcall;
//
//   /// threads.h
//   ///
//
//   // GIT_EXTERN(void) git_threads_init(void);
//   git_threads_init:                   procedure; stdcall;
//   // GIT_EXTERN(void) git_threads_shutdown(void);
//   git_threads_shutdown:               procedure; stdcall;
//
//   /// tree.h
//   ///
//
//   // GIT_EXTERN(const git_oid *) git_tree_id(git_tree *tree);
//   git_tree_id:                        function (tree: Pgit_tree): Pgit_oid; stdcall;
//   // GIT_EXTERN(unsigned int) git_tree_entrycount(git_tree *tree);
//   git_tree_entrycount:                function (tree: Pgit_tree): UInt; stdcall;
//   // GIT_EXTERN(const git_tree_entry *) git_tree_entry_byname(git_tree *tree, const char *filename);
//   git_tree_entry_byname:              function (tree: Pgit_tree; const filename: PAnsiChar): Pgit_tree_entry; stdcall;
//   // GIT_EXTERN(const git_tree_entry *) git_tree_entry_byindex(git_tree *tree, unsigned int idx);
//   git_tree_entry_byindex:             function (tree: Pgit_tree; idx: UInt): Pgit_tree_entry; stdcall;
//   // GIT_EXTERN(unsigned int) git_tree_entry_attributes(const git_tree_entry *entry);
//   git_tree_entry_attributes:          function (const entry: Pgit_tree_entry): UInt; stdcall;
//   // GIT_EXTERN(const char *) git_tree_entry_name(const git_tree_entry *entry);
//   git_tree_entry_name:                function (const entry: Pgit_tree_entry): PAnsiChar; stdcall;
//   // GIT_EXTERN(const git_oid *) git_tree_entry_id(const git_tree_entry *entry);
//   git_tree_entry_id:                  function (const entry: Pgit_tree_entry): Pgit_oid; stdcall;
//   // GIT_EXTERN(git_otype) git_tree_entry_type(const git_tree_entry *entry);
//   git_tree_entry_type:                function (const entry: Pgit_tree_entry): git_otype; stdcall;
//   // GIT_EXTERN(int) git_tree_entry_2object(git_object **object_out, git_repository *repo, const git_tree_entry *entry);
//   git_tree_entry_2object:             function (var object_out: Pgit_object; repo: PGitRepository; const entry: Pgit_tree_entry): Integer; stdcall;
//   // GIT_EXTERN(int) git_tree_create_fromindex(git_oid *oid, git_index *index);
//   git_tree_create_fromindex:          function (oid: Pgit_oid; index: Pgit_index): Integer; stdcall;
//
//   // GIT_EXTERN(int) git_treebuilder_create(git_treebuilder **builder_p, const git_tree *source);
//   git_treebuilder_create:             function (var builder_p: Pgit_treebuilder; const source: Pgit_tree): Integer; stdcall;
//   // GIT_EXTERN(void) git_treebuilder_clear(git_treebuilder *bld);
//   git_treebuilder_clear:              procedure (bld: Pgit_treebuilder); stdcall;
//   // GIT_EXTERN(void) git_treebuilder_free(git_treebuilder *bld);
//   git_treebuilder_free:               procedure (bld: Pgit_treebuilder); stdcall;
//   // GIT_EXTERN(const git_tree_entry *) git_treebuilder_get(git_treebuilder *bld, const char *filename);
//   git_treebuilder_get:                function (bld: Pgit_treebuilder; const filename: PAnsiChar): Pgit_tree_entry; stdcall;
//   // GIT_EXTERN(int) git_treebuilder_insert(git_tree_entry **entry_out, git_treebuilder *bld, const char *filename, const git_oid *id, unsigned int attributes);
//   git_treebuilder_insert:             function (var entry_out: Pgit_tree_entry; bld: Pgit_treebuilder; const filename: PAnsiChar; const id: Pgit_oid; attributes: UInt): Integer; stdcall;
//   // GIT_EXTERN(int) git_treebuilder_remove(git_treebuilder *bld, const char *filename);
//   git_treebuilder_remove:             function (bld: Pgit_treebuilder; const filename: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(void) git_treebuilder_filter(git_treebuilder *bld, int (*filter)(const git_tree_entry *, void *), void *payload);
//   git_treebuilder_filter:             procedure (bld: Pgit_treebuilder; filter: Pgit_treebuilder_filter_filter; payload: PByte); stdcall;
//   // GIT_EXTERN(int) git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld);
//   git_treebuilder_write:              function (oid:Pgit_oid; repo: PGitRepository; bld: Pgit_treebuilder): Integer; stdcall;
//   // GIT_EXTERN(int) git_tree_get_subtree(git_tree **subtree, git_tree *root, const char *subtree_path);
//   git_tree_get_subtree:               function (var subtree: Pgit_tree; root: Pgit_tree; subtree_path: PAnsiChar): Integer; stdcall;
//   // GIT_EXTERN(int) git_tree_walk(git_tree *tree, git_treewalk_cb callback, int mode, void *payload);
//   git_tree_walk:                      function (tree: Pgit_tree; callback: Pgit_treewalk_cb; mode: Integer; payload: PByte): Integer;
//
//   /// windows.h
//   ///
//
//   // GIT_EXTERN(void) gitwin_set_codepage(unsigned int codepage);
//   gitwin_set_codepage:                procedure (codepage: UInt); stdcall;
//   // GIT_EXTERN(unsigned int) gitwin_get_codepage(void);
//   gitwin_get_codepage:                function (): UInt; stdcall;
//   // GIT_EXTERN(void) gitwin_set_utf8(void);
//   gitwin_set_utf8:                    procedure (); stdcall;

//// GIT_EXTERNs later inlined
//function git_blob_lookup(var blob: Pgit_blob; repo: PGitRepository; const id: Pgit_oid): Integer; stdcall;
//function git_commit_lookup(var commit: Pgit_commit; repo: PGitRepository; const id: Pgit_oid): Integer; stdcall;
//function git_tag_lookup(var tag: Pgit_tag; repo: PGitRepository; const id: Pgit_oid): Integer; stdcall;
//procedure git_commit_free(commit: Pgit_commit);
//procedure git_tag_free(tag: Pgit_tag);

// Helpers
(*
function time_t__to__TDateTime(t: time_t; const aAdjustMinutes: Integer = 0): TDateTime;
function git_commit_DateTime(commit: Pgit_commit): TDateTime;
*)

const
  cGit2Dll = 'git2.dll';

function InitLibgit2: Boolean;

implementation

var
  libgit2: THandle;

//function git_blob_lookup(var blob: Pgit_blob; repo: PGitRepository; const id: Pgit_oid): Integer; stdcall;
//begin
//   // return git_object_lookup((git_object **)blob, repo, id, GIT_OBJ_BLOB);
//   Result := git_object_lookup(Pgit_object(blob), repo, id, GIT_OBJ_BLOB);
//end;
//
//function git_commit_lookup(var commit: Pgit_commit; repo: PGitRepository; const id: Pgit_oid): Integer; stdcall;
//begin
//   // return git_object_lookup((git_object **)commit, repo, id, GIT_OBJ_COMMIT);
//   Result := git_object_lookup(commit, repo, id, GIT_OBJ_COMMIT);
//end;
//
//function git_tag_lookup(var tag: Pgit_tag; repo: PGitRepository; const id: Pgit_oid): Integer; stdcall;
//begin
//   // return git_object_lookup((git_object **)tag, repo, id, GIT_OBJ_TAG);
//   Result := git_object_lookup(Pgit_object(tag), repo, id, GIT_OBJ_TAG);
//end;
//
//procedure git_commit_free(commit: Pgit_commit);
//begin
//   git_object_free(commit);
//end;
//
//procedure git_tag_free(tag: Pgit_tag);
//begin
//   git_object_free(tag);
//end;
//
(*
function time_t__to__TDateTime(t: time_t; const aAdjustMinutes: Integer = 0): TDateTime;
const
   UnixStartDate: TDateTime = 25569.0; // 01/01/1970
begin
   Result := (t / SecsPerDay) + UnixStartDate;                          //   Result := DateUtils.IncSecond(EncodeDate(1970,1,1), t);
   if aAdjustMinutes <> 0 then
      Result := ((Result * MinsPerDay) + aAdjustMinutes) / MinsPerDay;  //      Result := DateUtils.IncMinute(Result, aAdjustMinutes);
end;

function git_commit_DateTime(commit: Pgit_commit): TDateTime;
var
   t: time_t;
   time_offset: Integer;
begin
   t := git_commit_time(commit);
   time_offset := git_commit_time_offset(commit);

   Result := time_t__to__TDateTime(t, time_offset);
end;
*)

procedure BindFuncs(aBind: Boolean);

  function Bind(const aName :AnsiString; aRaise :Boolean = True): Pointer;
  begin
    Result := nil;
    if aBind then
      Result := GetProcAddressEx(libgit2, aName, aRaise);
  end;

begin
   git_libgit2_init                 := Bind('git_libgit2_init');
   git_libgit2_shutdown             := Bind('git_libgit2_shutdown');

   git_repository_open              := Bind('git_repository_open');
   git_repository_open_ext          := Bind('git_repository_open_ext');
   git_repository_set_head          := Bind('git_repository_set_head');
   git_repository_set_head_detached := Bind('git_repository_set_head_detached');
   git_repository_set_head_detached_from_annotated := Bind('git_repository_set_head_detached_from_annotated');
   git_repository_free              := Bind('git_repository_free');

   git_status_foreach               := Bind('git_status_foreach');
   git_status_foreach_ext           := Bind('git_status_foreach_ext');
   git_status_list_new              := Bind('git_status_list_new');
   git_status_list_free             := Bind('git_status_list_free');
   git_status_list_entrycount       := Bind('git_status_list_entrycount');
   git_status_byindex               := Bind('git_status_byindex');

   git_repository_workdir           := Bind('git_repository_workdir');

   git_repository_head              := Bind('git_repository_head');
   git_repository_head_unborn       := Bind('git_repository_head_unborn');
   git_repository_head_detached     := Bind('git_repository_head_detached');

   git_reference_name               := Bind('git_reference_name');
   git_reference_name_to_id         := Bind('git_reference_name_to_id');
   git_reference_shorthand          := Bind('git_reference_shorthand');
   git_reference_symbolic_target    := Bind('git_reference_symbolic_target');
   git_reference_lookup             := Bind('git_reference_lookup');
   git_reference_dwim               := Bind('git_reference_dwim');
   git_reference_is_branch          := Bind('git_reference_is_branch');
   git_reference_is_remote          := Bind('git_reference_is_remote');
   git_reference_is_tag             := Bind('git_reference_is_tag');
   git_reference_target             := Bind('git_reference_target');
   git_reference_free               := Bind('git_reference_free');

   git_revparse_single              := Bind('git_revparse_single');
   git_object_lookup                := Bind('git_object_lookup');
   git_object_type                  := Bind('git_object_type');
   git_object_id                    := Bind('git_object_id');
   git_object_short_id              := Bind('git_object_short_id');
   git_object_free                  := Bind('git_object_free');

   git_blob_rawsize                 := Bind('git_blob_rawsize');
   git_blob_rawcontent              := Bind('git_blob_rawcontent');
   git_blob_filtered_content        := Bind('git_blob_filtered_content');

   git_revwalk_new                  := Bind('git_revwalk_new');
   git_revwalk_push_head            := Bind('git_revwalk_push_head');
   git_revwalk_next                 := Bind('git_revwalk_next');
   git_revwalk_free                 := Bind('git_revwalk_free');

   git_commit_create                := Bind('git_commit_create');
   git_commit_amend                 := Bind('git_commit_amend');
   git_commit_lookup                := Bind('git_commit_lookup');
   git_commit_free                  := Bind('git_commit_free');
   git_commit_id                    := Bind('git_commit_id');
   git_commit_author                := Bind('git_commit_author');
   git_commit_message               := Bind('git_commit_message');
   git_commit_parentcount           := Bind('git_commit_parentcount');
   git_commit_parent                := Bind('git_commit_parent');
   git_commit_tree                  := Bind('git_commit_tree');

   git_tree_lookup                  := Bind('git_tree_lookup');
   git_tree_free                    := Bind('git_tree_free');

   git_annotated_commit_from_ref    := Bind('git_annotated_commit_from_ref');
   git_annotated_commit_free        := Bind('git_annotated_commit_free');

   git_diff_tree_to_tree            := Bind('git_diff_tree_to_tree');
   git_diff_tree_to_workdir         := Bind('git_diff_tree_to_workdir');
   git_diff_num_deltas              := Bind('git_diff_num_deltas');
   git_diff_foreach                 := Bind('git_diff_foreach');
   git_diff_print                   := Bind('git_diff_print');
   git_diff_free                    := Bind('git_diff_free');

   git_branch_iterator_new          := Bind('git_branch_iterator_new');
   git_branch_next                  := Bind('git_branch_next');
   git_branch_iterator_free         := Bind('git_branch_iterator_free');
   git_branch_name                  := Bind('git_branch_name');
   git_branch_is_head               := Bind('git_branch_is_head');
   git_branch_create                := Bind('git_branch_create');
   git_branch_move                  := Bind('git_branch_move');
   git_branch_delete                := Bind('git_branch_delete');

   git_checkout_tree                := Bind('git_checkout_tree');

   git_tag_foreach                  := Bind('git_tag_foreach');

   git_repository_index             := Bind('git_repository_index');
   git_index_entrycount             := Bind('git_index_entrycount');
   git_index_add_bypath             := Bind('git_index_add_bypath');
   git_index_add_all                := Bind('git_index_add_all');
   git_index_remove_bypath          := Bind('git_index_remove_bypath');
   git_index_remove                 := Bind('git_index_remove');
   git_index_clear                  := Bind('git_index_clear');
   git_index_write                  := Bind('git_index_write');
   git_index_write_tree             := Bind('git_index_write_tree');
   git_index_free                   := Bind('git_index_free');

   git_reset_default                := Bind('git_reset_default');

   git_signature_default            := Bind('git_signature_default');
   git_signature_now                := Bind('git_signature_now');
   git_signature_free               := Bind('git_signature_free');

   git_remote_list                  := Bind('git_remote_list');
   git_remote_lookup                := Bind('git_remote_lookup');
   git_remote_url                   := Bind('git_remote_url');
   git_remote_free                  := Bind('git_remote_free');

   git_pathspec_new                 := Bind('git_pathspec_new');
   git_pathspec_match_tree          := Bind('git_pathspec_match_tree');
   git_pathspec_free                := Bind('git_pathspec_free');

   git_strarray_free                := Bind('git_strarray_free');
   git_buf_free                     := Bind('git_buf_free');

   git_oid_tostr                    := Bind('git_oid_tostr');

//   git_attr_get                     := Bind('git_attr_get', '16');
//   git_attr_get_many                := Bind('git_attr_get_many', '20');
//   git_attr_foreach                 := Bind('git_attr_foreach', '16');
//   git_attr_cache_flush             := Bind('git_attr_cache_flush', '4');
//   git_attr_add_macro               := Bind('git_attr_add_macro', '12');
//
//// git_blob_create_fromfile         := Bind('git_blob_create_fromfile', '12');
//   git_blob_create_frombuffer       := Bind('git_blob_create_frombuffer', '16');
//
//   git_commit_message_encoding      := Bind('git_commit_message_encoding', '4');
//   git_commit_time                  := Bind('git_commit_time', '4');
//   git_commit_time_offset           := Bind('git_commit_time_offset', '4');
//   git_commit_committer             := Bind('git_commit_committer', '4');
//// git_commit_tree_oid              := Bind('git_commit_tree_oid', '4');
//// git_commit_parent_oid            := Bind('git_commit_parent_oid', '8');
//
//   git_libgit2_version              := Bind('git_libgit2_version', '12');
//
//   git_config_find_global           := Bind('git_config_find_global', '4');
//   git_config_find_system           := Bind('git_config_find_system', '4');
//   git_config_open_global           := Bind('git_config_open_global', '4');
//// git_config_file__ondisk          := Bind('git_config_file__ondisk', '8');
//   git_config_new                   := Bind('git_config_new', '4');
//// git_config_add_file              := Bind('git_config_add_file', '12');
//   git_config_add_file_ondisk       := Bind('git_config_add_file_ondisk', '12');
//   git_config_open_ondisk           := Bind('git_config_open_ondisk', '8');
//   git_config_free                  := Bind('git_config_free', '4');
//   git_config_get_int32             := Bind('git_config_get_int32', '12');
//   git_config_get_int64             := Bind('git_config_get_int64', '12');
//   git_config_get_bool              := Bind('git_config_get_bool', '12');
//   git_config_get_string            := Bind('git_config_get_string', '12');
//   git_config_set_int32             := Bind('git_config_set_int32', '12');
//   git_config_set_int64             := Bind('git_config_set_int64', '16');
//   git_config_set_bool              := Bind('git_config_set_bool', '12');
//   git_config_set_string            := Bind('git_config_set_string', '12');
//// git_config_delete                := Bind('git_config_delete', '8');
//   git_config_foreach               := Bind('git_config_foreach', '12');

//   git_lasterror                    := Bind('git_lasterror', '0');
//   git_strerror                     := Bind('git_strerror', '4');
//   git_clearerror                   := Bind('git_clearerror', '0');
//
//   git_index_open                   := Bind('git_index_open', '8');
//   git_index_read                   := Bind('git_index_read', '4');
//   git_index_write                  := Bind('git_index_write', '4');
//   git_index_find                   := Bind('git_index_find', '8');
//   git_index_uniq                   := Bind('git_index_uniq', '4');
//   git_index_add                    := Bind('git_index_add', '12');
//   git_index_add2                   := Bind('git_index_add2', '8');
//   git_index_append                 := Bind('git_index_append', '12');
//   git_index_append2                := Bind('git_index_append2', '8');
//   git_index_get                    := Bind('git_index_get', '8');
//   git_index_entrycount             := Bind('git_index_entrycount', '4');
//   git_index_entrycount_unmerged    := Bind('git_index_entrycount_unmerged', '4');
//   git_index_get_unmerged_bypath    := Bind('git_index_get_unmerged_bypath', '8');
//   git_index_get_unmerged_byindex   := Bind('git_index_get_unmerged_byindex', '8');
//   git_index_entry_stage            := Bind('git_index_entry_stage', '4');
//   git_index_read_tree              := Bind('git_index_read_tree', '8');
//
//   git_indexer_new                  := Bind('git_indexer_new', '8');
//   git_indexer_run                  := Bind('git_indexer_run', '8');
//   git_indexer_write                := Bind('git_indexer_write', '4');
//   git_indexer_hash                 := Bind('git_indexer_hash', '4');
//   git_indexer_free                 := Bind('git_indexer_free', '4');
//
//   git_object_lookup_prefix         := Bind('git_object_lookup_prefix', '20');
//   git_object_owner                 := Bind('git_object_owner', '4');
//   git_object_free                  := Bind('git_object_free', '4');
//   git_object_type2string           := Bind('git_object_type2string', '4');
//   git_object_string2type           := Bind('git_object_string2type', '4');
//   git_object_typeisloose           := Bind('git_object_typeisloose', '4');
//   git_object__size                 := Bind('git_object__size', '4');
//
//   git_odb_new                      := Bind('git_odb_new', '4');
//   git_odb_open                     := Bind('git_odb_open', '8');
//   git_odb_add_backend              := Bind('git_odb_add_backend', '12');
//   git_odb_add_alternate            := Bind('git_odb_add_alternate', '12');
//   git_odb_free                     := Bind('git_odb_free', '4');
//   git_odb_read                     := Bind('git_odb_read', '12');
//   git_odb_read_prefix              := Bind('git_odb_read_prefix', '16');
//   git_odb_read_header              := Bind('git_odb_read_header', '16');
//   git_odb_exists                   := Bind('git_odb_exists', '8');
//   git_odb_write                    := Bind('git_odb_write', '20');
//   git_odb_open_wstream             := Bind('git_odb_open_wstream', '16');
//   git_odb_open_rstream             := Bind('git_odb_open_rstream', '12');
//   git_odb_hash                     := Bind('git_odb_hash', '16');
//   git_odb_hashfile                 := Bind('git_odb_hashfile', '12');
//   git_odb_object_free              := Bind('git_odb_object_free', '4');
//   git_odb_object_id                := Bind('git_odb_object_id', '4');
//   git_odb_object_data              := Bind('git_odb_object_data', '4');
//   git_odb_object_size              := Bind('git_odb_object_size', '4');
//   git_odb_object_type              := Bind('git_odb_object_type', '4');
//
//   git_odb_backend_pack             := Bind('git_odb_backend_pack', '8');
//   git_odb_backend_loose            := Bind('git_odb_backend_loose', '16');
//
//   git_oid_fromstr                  := Bind('git_oid_fromstr', '8');
//   git_oid_fromstrn                 := Bind('git_oid_fromstrn', '12');
//   git_oid_fromraw                  := Bind('git_oid_fromraw', '8');
//   git_oid_fmt                      := Bind('git_oid_fmt', '8');
//   git_oid_pathfmt                  := Bind('git_oid_pathfmt', '8');
//   git_oid_allocfmt                 := Bind('git_oid_allocfmt', '4');
//   git_oid_to_string                := Bind('git_oid_to_string', '12');
//   git_oid_cpy                      := Bind('git_oid_cpy', '8');
//   git_oid_cmp                      := Bind('git_oid_cmp', '8');
//   git_oid_ncmp                     := Bind('git_oid_ncmp', '12');
//   git_oid_streq                    := Bind('git_oid_streq', '8');
//
//   git_reflog_read                  := Bind('git_reflog_read', '8');
//   git_reflog_write                 := Bind('git_reflog_write', '16');
//   git_reflog_rename                := Bind('git_reflog_rename', '8');
//   git_reflog_delete                := Bind('git_reflog_delete', '4');
//   git_reflog_entrycount            := Bind('git_reflog_entrycount', '4');
//   git_reflog_entry_byindex         := Bind('git_reflog_entry_byindex', '8');
//   git_reflog_entry_oidold          := Bind('git_reflog_entry_oidold', '4');
//   git_reflog_entry_oidnew          := Bind('git_reflog_entry_oidnew', '4');
//   git_reflog_entry_committer       := Bind('git_reflog_entry_committer', '4');
//   git_reflog_entry_msg             := Bind('git_reflog_entry_msg', '4');
//   git_reflog_free                  := Bind('git_reflog_free', '4');
//
//   git_reference_create_symbolic    := Bind('git_reference_create_symbolic', '20');
//   git_reference_create_oid         := Bind('git_reference_create_oid', '20');
//   git_reference_oid                := Bind('git_reference_oid', '4');
//   git_reference_target             := Bind('git_reference_target', '4');
//   git_reference_type               := Bind('git_reference_type', '4');
//   git_reference_resolve            := Bind('git_reference_resolve', '8');
//   git_reference_owner              := Bind('git_reference_owner', '4');
//   git_reference_set_target         := Bind('git_reference_set_target', '8');
//   git_reference_set_oid            := Bind('git_reference_set_oid', '8');
//   git_reference_rename             := Bind('git_reference_rename', '12');
//   git_reference_delete             := Bind('git_reference_delete', '4');
//   git_reference_packall            := Bind('git_reference_packall', '4');
//   git_reference_listall            := Bind('git_reference_listall', '12');
//   git_reference_foreach            := Bind('git_reference_foreach', '16');
//   git_reference_is_packed          := Bind('git_reference_is_packed', '4');
//   git_reference_reload             := Bind('git_reference_reload', '4');
//
//   git_remote_new                   := Bind('git_remote_new', '16');
//   git_remote_load                  := Bind('git_remote_load', '12');
//   git_remote_name                  := Bind('git_remote_name', '4');
//   git_remote_fetchspec             := Bind('git_remote_fetchspec', '4');
//   git_remote_pushspec              := Bind('git_remote_pushspec', '4');
//   git_remote_connect               := Bind('git_remote_connect', '8');
//   git_remote_ls                    := Bind('git_remote_ls', '12');
//   git_remote_download              := Bind('git_remote_download', '8');
//   git_remote_connected             := Bind('git_remote_connected', '4');
//   git_remote_disconnect            := Bind('git_remote_disconnect', '4');
//   git_remote_update_tips           := Bind('git_remote_update_tips', '4');
//   git_remote_valid_url             := Bind('git_remote_valid_url', '4');

//   git_repository_discover          := Bind('git_repository_discover', '20');
//   git_repository_init              := Bind('git_repository_init', '12');
//   git_repository_is_empty          := Bind('git_repository_is_empty', '4');
//   git_repository_path              := Bind('git_repository_path', '4');
//   git_repository_set_workdir       := Bind('git_repository_set_workdir', '8');
//   git_repository_is_bare           := Bind('git_repository_is_bare', '4');
//   git_repository_config            := Bind('git_repository_config', '8');
//   git_repository_set_config        := Bind('git_repository_set_config', '8');
//   git_repository_odb               := Bind('git_repository_odb', '8');
//   git_repository_set_odb           := Bind('git_repository_set_odb', '8');
//   git_repository_set_index         := Bind('git_repository_set_index', '8');
//
//   git_revwalk_reset                := Bind('git_revwalk_reset', '4');
//   git_revwalk_push                 := Bind('git_revwalk_push', '8');
//   git_revwalk_hide                 := Bind('git_revwalk_hide', '8');
//   git_revwalk_sorting              := Bind('git_revwalk_sorting', '8');
//   git_revwalk_repository           := Bind('git_revwalk_repository', '4');
//
//   git_signature_new                := Bind('git_signature_new', '24');
//   git_signature_dup                := Bind('git_signature_dup', '4');
//   git_signature_free               := Bind('git_signature_free', '4');
//
//   git_status_file                  := Bind('git_status_file', '12');
//   git_status_should_ignore         := Bind('git_status_should_ignore', '12');
//
//   git_tag_id                       := Bind('git_tag_id', '4');
//   git_tag_target                   := Bind('git_tag_target', '8');
//   git_tag_target_oid               := Bind('git_tag_target_oid', '4');
//   git_tag_type                     := Bind('git_tag_type', '4');
//   git_tag_name                     := Bind('git_tag_name', '4');
//   git_tag_tagger                   := Bind('git_tag_tagger', '4');
//   git_tag_message                  := Bind('git_tag_message', '4');
//   git_tag_create                   := Bind('git_tag_create', '28');
//   git_tag_create_frombuffer        := Bind('git_tag_create_frombuffer', '16');
//   git_tag_create_lightweight       := Bind('git_tag_create_lightweight', '20');
//   git_tag_delete                   := Bind('git_tag_delete', '8');
//   git_tag_list                     := Bind('git_tag_list', '8');
//   git_tag_list_match               := Bind('git_tag_list_match', '12');
//
//   git_threads_init                 := Bind('git_threads_init', '0');
//   git_threads_shutdown             := Bind('git_threads_shutdown', '0');
//
//   git_tree_id                      := Bind('git_tree_id', '4');
//   git_tree_entrycount              := Bind('git_tree_entrycount', '4');
//   git_tree_entry_byname            := Bind('git_tree_entry_byname', '8');
//   git_tree_entry_byindex           := Bind('git_tree_entry_byindex', '8');
//   git_tree_entry_attributes        := Bind('git_tree_entry_attributes', '4');
//   git_tree_entry_name              := Bind('git_tree_entry_name', '4');
//   git_tree_entry_id                := Bind('git_tree_entry_id', '4');
//   git_tree_entry_type              := Bind('git_tree_entry_type', '4');
//   git_tree_entry_2object           := Bind('git_tree_entry_2object', '12');
//   git_tree_create_fromindex        := Bind('git_tree_create_fromindex', '8');
//
//   git_treebuilder_create           := Bind('git_treebuilder_create', '8');
//   git_treebuilder_clear            := Bind('git_treebuilder_clear', '4');
//   git_treebuilder_free             := Bind('git_treebuilder_free', '4');
//   git_treebuilder_get              := Bind('git_treebuilder_get', '8');
//   git_treebuilder_insert           := Bind('git_treebuilder_insert', '20');
//   git_treebuilder_remove           := Bind('git_treebuilder_remove', '8');
//   git_treebuilder_filter           := Bind('git_treebuilder_filter', '12');
//   git_treebuilder_write            := Bind('git_treebuilder_write', '12');
//   git_tree_get_subtree             := Bind('git_tree_get_subtree', '12');
//   git_tree_walk                    := Bind('git_tree_walk', '16');

   // TODO : not exported?
//   gitwin_set_codepage              := Bind('gitwin_set_codepage', '');
//   gitwin_get_codepage              := Bind('gitwin_get_codepage', '');
//   gitwin_set_utf8                  := Bind('gitwin_set_utf8', '');

end;

function InitLibgit2: Boolean;
var
  vRes :Integer;
begin
  if libgit2 = 0 then begin
    libgit2 := LoadLibraryEx(cGit2Dll);
    if libgit2 > 0 then
      BindFuncs(true);
    vRes := git_libgit2_init;
    if vRes < 0 then
      {};
  end;
  Result := libgit2 > 0;
end;

procedure FreeLibgit2;
begin
  if libgit2 <> 0 then begin
    if Assigned(git_libgit2_shutdown) then
      git_libgit2_shutdown;
    FreeLibrary(libgit2);
    libgit2 := 0;
    BindFuncs(false);
  end;
end;

initialization
  libgit2 := 0;

finalization
  FreeLibgit2;

end.
